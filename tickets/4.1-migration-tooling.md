# Ticket 4.2: Create Migration Tooling

## üìã Ticket Details
**Phase**: 4 - Unified Consent & Migration  
**Estimate**: 2 days  
**Priority**: High  
**Assignee**: TBD  
**Status**: Ready  

## üéØ Description
Build comprehensive migration tools to seamlessly migrate from event-sidekick to the new c15t analytics system. This includes automated migration scripts, compatibility layers, feature flags, and rollback capabilities to ensure a smooth transition with minimal disruption.

## üß† Context & Background
This ticket creates migration tooling for transitioning from event-sidekick to the new analytics system where:

- **Automated migration** converts event-sidekick configurations to c15t format
- **Compatibility layer** maintains existing API compatibility during transition
- **Feature flags** enable gradual rollout and A/B testing
- **Rollback capabilities** allow quick reversion if issues arise
- **Migration validation** ensures data integrity and configuration correctness
- **Two deployment models** supported:
  - **Consent.io SaaS**: Migrate to control plane with database destinations
  - **Self-hosted**: Migrate to direct configuration with c15tInstance

The migration tooling must:
- Convert event-sidekick configurations to c15t format
- Maintain API compatibility during transition period
- Support gradual rollout with feature flags
- Provide rollback mechanisms for safety
- Validate migrated configurations
- Handle both consent.io and self-hosted migrations

## ‚úÖ Acceptance Criteria
- [ ] Create migration script for event-sidekick configs
- [ ] Create compatibility layer for existing APIs
- [ ] Add feature flags for gradual rollout
- [ ] Add rollback capabilities
- [ ] Add migration validation
- [ ] Support both consent.io and self-hosted migrations
- [ ] Unit tests for migration tools

## üìÅ Files to Create
- `packages/scripts/src/migrate-event-sidekick.ts`
- `packages/backend/src/v2/compatibility/event-sidekick-adapter.ts`
- `packages/scripts/src/migration-validator.ts`
- `packages/scripts/src/rollback-manager.ts`

## üîß Implementation Details

### Event-Sidekick Migration Script
```typescript
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';
import { Logger } from '@c15t/logger';

interface EventSidekickConfig {
  destinations: {
    type: string;
    config: Record<string, unknown>;
    enabled?: boolean;
  }[];
  consent?: {
    enabled: boolean;
    purposes: string[];
  };
  features?: {
    serverSide: boolean;
    clientSide: boolean;
  };
}

interface C15TConfig {
  analytics: {
    destinations: Array<{
      type: string;
      settings: Record<string, unknown>;
      requiredConsent: string[];
    }>;
  };
  consent?: {
    integrateWithExistingCMP: boolean;
    cmpType?: string;
  };
}

export class EventSidekickMigrator {
  private logger: Logger;

  constructor(logger?: Logger) {
    this.logger = logger || new Logger({ component: 'migration' });
  }

  async migrateConfig(
    inputPath: string,
    outputPath: string,
    options: {
      targetType: 'consent-io' | 'self-hosted';
      organizationId?: string;
      environment?: 'development' | 'staging' | 'production';
    }
  ): Promise<MigrationResult> {
    try {
      this.logger.info('Starting event-sidekick migration', {
        inputPath,
        outputPath,
        targetType: options.targetType,
      });

      // Read event-sidekick configuration
      const eventSidekickConfig = this.readEventSidekickConfig(inputPath);
      
      // Validate input configuration
      const validationResult = this.validateEventSidekickConfig(eventSidekickConfig);
      if (!validationResult.valid) {
        throw new Error(`Invalid event-sidekick config: ${validationResult.errors.join(', ')}`);
      }

      // Convert to c15t format
      const c15tConfig = await this.convertToC15T(eventSidekickConfig, options);

      // Write migrated configuration
      this.writeC15TConfig(outputPath, c15tConfig);

      // Generate migration report
      const report = this.generateMigrationReport(eventSidekickConfig, c15tConfig);

      this.logger.info('Migration completed successfully', {
        destinationsMigrated: report.destinationsMigrated,
        warnings: report.warnings.length,
      });

      return {
        success: true,
        report,
        config: c15tConfig,
      };

    } catch (error) {
      this.logger.error('Migration failed', {
        error: error.message,
        inputPath,
        outputPath,
      });

      return {
        success: false,
        error: error.message,
        report: null,
        config: null,
      };
    }
  }

  private readEventSidekickConfig(path: string): EventSidekickConfig {
    if (!existsSync(path)) {
      throw new Error(`Event-sidekick config file not found: ${path}`);
    }

    try {
      const content = readFileSync(path, 'utf-8');
      return JSON.parse(content);
    } catch (error) {
      throw new Error(`Failed to read event-sidekick config: ${error.message}`);
    }
  }

  private validateEventSidekickConfig(config: EventSidekickConfig): ValidationResult {
    const errors: string[] = [];

    if (!config.destinations || !Array.isArray(config.destinations)) {
      errors.push('destinations array is required');
    }

    if (config.destinations) {
      config.destinations.forEach((dest, index) => {
        if (!dest.type) {
          errors.push(`destination[${index}].type is required`);
        }
        if (!dest.config) {
          errors.push(`destination[${index}].config is required`);
        }
      });
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  private async convertToC15T(
    eventSidekickConfig: EventSidekickConfig,
    options: MigrationOptions
  ): Promise<C15TConfig> {
    const c15tConfig: C15TConfig = {
      analytics: {
        destinations: [],
      },
    };

    // Convert destinations
    for (const dest of eventSidekickConfig.destinations) {
      if (!dest.enabled) continue;

      const convertedDest = await this.convertDestination(dest, options);
      if (convertedDest) {
        c15tConfig.analytics.destinations.push(convertedDest);
      }
    }

    // Convert consent configuration
    if (eventSidekickConfig.consent) {
      c15tConfig.consent = {
        integrateWithExistingCMP: true,
        cmpType: 'event-sidekick', // Mark as migrated from event-sidekick
      };
    }

    return c15tConfig;
  }

  private async convertDestination(
    dest: EventSidekickConfig['destinations'][0],
    options: MigrationOptions
  ): Promise<C15TConfig['analytics']['destinations'][0] | null> {
    const destinationMappings = {
      'posthog': this.convertPostHogDestination,
      'meta-pixel': this.convertMetaPixelDestination,
      'google-analytics': this.convertGoogleAnalyticsDestination,
      'mixpanel': this.convertMixpanelDestination,
      'amplitude': this.convertAmplitudeDestination,
      'console': this.convertConsoleDestination,
    };

    const converter = destinationMappings[dest.type as keyof typeof destinationMappings];
    if (!converter) {
      this.logger.warn('Unknown destination type', { type: dest.type });
      return null;
    }

    try {
      return await converter.call(this, dest.config, options);
    } catch (error) {
      this.logger.error('Failed to convert destination', {
        type: dest.type,
        error: error.message,
      });
      return null;
    }
  }

  private async convertPostHogDestination(
    config: Record<string, unknown>,
    options: MigrationOptions
  ): Promise<C15TConfig['analytics']['destinations'][0]> {
    return {
      type: 'posthog',
      settings: {
        apiKey: config.apiKey,
        host: config.host || 'https://app.posthog.com',
        enableServerSide: config.serverSide !== false,
        enableClientSide: config.clientSide !== false,
      },
      requiredConsent: this.getRequiredConsent('posthog', config),
    };
  }

  private async convertMetaPixelDestination(
    config: Record<string, unknown>,
    options: MigrationOptions
  ): Promise<C15TConfig['analytics']['destinations'][0]> {
    return {
      type: 'meta-pixel',
      settings: {
        pixelId: config.pixelId,
        accessToken: config.accessToken,
        testEventCode: config.testEventCode,
        apiVersion: config.apiVersion || 'v18.0',
        enableServerSide: config.serverSide !== false,
        enableClientSide: config.clientSide !== false,
      },
      requiredConsent: this.getRequiredConsent('meta-pixel', config),
    };
  }

  private async convertGoogleAnalyticsDestination(
    config: Record<string, unknown>,
    options: MigrationOptions
  ): Promise<C15TConfig['analytics']['destinations'][0]> {
    return {
      type: 'google-analytics',
      settings: {
        measurementId: config.measurementId,
        apiSecret: config.apiSecret,
        enableServerSide: config.serverSide !== false,
        enableClientSide: config.clientSide !== false,
        enableEnhancedMeasurement: config.enhancedMeasurement !== false,
        anonymizeIp: config.anonymizeIp !== false,
      },
      requiredConsent: this.getRequiredConsent('google-analytics', config),
    };
  }

  private async convertMixpanelDestination(
    config: Record<string, unknown>,
    options: MigrationOptions
  ): Promise<C15TConfig['analytics']['destinations'][0]> {
    return {
      type: 'mixpanel',
      settings: {
        token: config.token,
        apiSecret: config.apiSecret,
        serverUrl: config.serverUrl || 'https://api.mixpanel.com',
      },
      requiredConsent: this.getRequiredConsent('mixpanel', config),
    };
  }

  private async convertAmplitudeDestination(
    config: Record<string, unknown>,
    options: MigrationOptions
  ): Promise<C15TConfig['analytics']['destinations'][0]> {
    return {
      type: 'amplitude',
      settings: {
        apiKey: config.apiKey,
        apiSecret: config.apiSecret,
        serverUrl: config.serverUrl || 'https://api2.amplitude.com',
      },
      requiredConsent: this.getRequiredConsent('amplitude', config),
    };
  }

  private async convertConsoleDestination(
    config: Record<string, unknown>,
    options: MigrationOptions
  ): Promise<C15TConfig['analytics']['destinations'][0]> {
    return {
      type: 'console',
      settings: {
        logLevel: config.logLevel || 'info',
      },
      requiredConsent: ['necessary'], // Console logging is always necessary
    };
  }

  private getRequiredConsent(destinationType: string, config: Record<string, unknown>): string[] {
    // Default consent requirements based on destination type
    const consentMappings = {
      'posthog': ['necessary', 'measurement'],
      'meta-pixel': ['necessary', 'measurement', 'marketing'],
      'google-analytics': ['necessary', 'measurement'],
      'mixpanel': ['necessary', 'measurement'],
      'amplitude': ['necessary', 'measurement'],
      'console': ['necessary'],
    };

    return consentMappings[destinationType as keyof typeof consentMappings] || ['necessary'];
  }

  private writeC15TConfig(path: string, config: C15TConfig): void {
    const content = JSON.stringify(config, null, 2);
    writeFileSync(path, content, 'utf-8');
  }

  private generateMigrationReport(
    original: EventSidekickConfig,
    migrated: C15TConfig
  ): MigrationReport {
    const warnings: string[] = [];
    const destinationsMigrated = migrated.analytics.destinations.length;
    const destinationsSkipped = original.destinations.length - destinationsMigrated;

    if (destinationsSkipped > 0) {
      warnings.push(`${destinationsSkipped} destinations were skipped during migration`);
    }

    return {
      destinationsMigrated,
      destinationsSkipped,
      warnings,
      originalConfig: original,
      migratedConfig: migrated,
    };
  }
}

// Types for migration
interface MigrationOptions {
  targetType: 'consent-io' | 'self-hosted';
  organizationId?: string;
  environment?: 'development' | 'staging' | 'production';
}

interface MigrationResult {
  success: boolean;
  error?: string;
  report?: MigrationReport | null;
  config?: C15TConfig | null;
}

interface MigrationReport {
  destinationsMigrated: number;
  destinationsSkipped: number;
  warnings: string[];
  originalConfig: EventSidekickConfig;
  migratedConfig: C15TConfig;
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
}
```

### Compatibility Layer for Existing APIs
```typescript
import { Request, Response } from 'express';
import { Logger } from '../logger';
import { EventProcessor } from '../analytics/event-processor';
import { DestinationManager } from '../analytics/destination-manager';

export class EventSidekickAdapter {
  constructor(
    private eventProcessor: EventProcessor,
    private destinationManager: DestinationManager,
    private logger: Logger
  ) {}

  // Adapter for event-sidekick track API
  async handleEventSidekickTrack(req: Request, res: Response): Promise<void> {
    try {
      const { event, properties, userId, sessionId } = req.body;

      // Convert event-sidekick format to c15t format
      const c15tEvent = this.convertEventSidekickEvent(event, properties);

      // Process through c15t analytics
      await this.eventProcessor.processEvent(c15tEvent, {
        userId,
        sessionId,
        timestamp: new Date().toISOString(),
      });

      res.json({ success: true });

    } catch (error) {
      this.logger.error('Event-sidekick adapter error', {
        error: error.message,
        endpoint: 'track',
      });

      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  // Adapter for event-sidekick page API
  async handleEventSidekickPage(req: Request, res: Response): Promise<void> {
    try {
      const { name, properties, userId, sessionId } = req.body;

      // Convert to c15t page event
      const c15tEvent = {
        type: 'page_view',
        properties: {
          page_name: name,
          ...properties,
        },
      };

      await this.eventProcessor.processEvent(c15tEvent, {
        userId,
        sessionId,
        timestamp: new Date().toISOString(),
      });

      res.json({ success: true });

    } catch (error) {
      this.logger.error('Event-sidekick adapter error', {
        error: error.message,
        endpoint: 'page',
      });

      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  // Adapter for event-sidekick identify API
  async handleEventSidekickIdentify(req: Request, res: Response): Promise<void> {
    try {
      const { userId, traits, sessionId } = req.body;

      // Convert to c15t identify event
      const c15tEvent = {
        type: 'identify',
        properties: {
          user_id: userId,
          traits,
        },
      };

      await this.eventProcessor.processEvent(c15tEvent, {
        userId,
        sessionId,
        timestamp: new Date().toISOString(),
      });

      res.json({ success: true });

    } catch (error) {
      this.logger.error('Event-sidekick adapter error', {
        error: error.message,
        endpoint: 'identify',
      });

      res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  private convertEventSidekickEvent(event: string, properties: Record<string, unknown>) {
    // Map event-sidekick event names to c15t event types
    const eventMappings = {
      'Page Viewed': 'page_view',
      'Product Viewed': 'product_viewed',
      'Product Added': 'add_to_cart',
      'Product Removed': 'remove_from_cart',
      'Cart Viewed': 'cart_viewed',
      'Checkout Started': 'checkout_started',
      'Order Completed': 'purchase',
      'User Signed Up': 'sign_up',
      'User Logged In': 'login',
      'User Logged Out': 'logout',
    };

    const c15tEventType = eventMappings[event as keyof typeof eventMappings] || 'custom_event';

    return {
      type: c15tEventType,
      properties: {
        ...properties,
        original_event_name: event,
      },
    };
  }
}
```

### Feature Flags for Gradual Rollout
```typescript
import { Logger } from '../logger';

export class MigrationFeatureFlags {
  private flags = new Map<string, boolean>();
  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  // Enable gradual migration rollout
  enableMigrationRollout(options: {
    percentage: number; // 0-100
    userIds?: string[];
    sessionIds?: string[];
  }): void {
    const { percentage, userIds, sessionIds } = options;

    this.flags.set('migration_enabled', true);
    this.flags.set('migration_percentage', percentage);
    
    if (userIds) {
      this.flags.set('migration_user_ids', userIds);
    }
    
    if (sessionIds) {
      this.flags.set('migration_session_ids', sessionIds);
    }

    this.logger.info('Migration rollout enabled', {
      percentage,
      userIdCount: userIds?.length || 0,
      sessionIdCount: sessionIds?.length || 0,
    });
  }

  // Check if migration should be enabled for this request
  shouldUseMigration(req: Request): boolean {
    const enabled = this.flags.get('migration_enabled');
    if (!enabled) return false;

    const percentage = this.flags.get('migration_percentage') || 0;
    const userIds = this.flags.get('migration_user_ids') as string[] | undefined;
    const sessionIds = this.flags.get('migration_session_ids') as string[] | undefined;

    // Check specific user/session lists first
    if (userIds && req.body.userId && userIds.includes(req.body.userId)) {
      return true;
    }

    if (sessionIds && req.body.sessionId && sessionIds.includes(req.body.sessionId)) {
      return true;
    }

    // Check percentage rollout
    const random = Math.random() * 100;
    return random < percentage;
  }

  // Enable A/B testing between old and new systems
  enableABTesting(options: {
    variant: 'old' | 'new' | 'both';
    percentage: number;
  }): void {
    this.flags.set('ab_testing_enabled', true);
    this.flags.set('ab_test_variant', options.variant);
    this.flags.set('ab_test_percentage', options.percentage);

    this.logger.info('A/B testing enabled', {
      variant: options.variant,
      percentage: options.percentage,
    });
  }

  // Get A/B test variant for request
  getABTestVariant(req: Request): 'old' | 'new' {
    const enabled = this.flags.get('ab_testing_enabled');
    if (!enabled) return 'old';

    const variant = this.flags.get('ab_test_variant') as string;
    const percentage = this.flags.get('ab_test_percentage') as number || 50;

    if (variant === 'old') return 'old';
    if (variant === 'new') return 'new';

    // Both variant - use percentage to decide
    const random = Math.random() * 100;
    return random < percentage ? 'new' : 'old';
  }

  // Disable migration (rollback)
  disableMigration(): void {
    this.flags.set('migration_enabled', false);
    this.flags.set('ab_testing_enabled', false);
    
    this.logger.info('Migration disabled - rolled back to event-sidekick');
  }
}
```

### Rollback Manager
```typescript
import { Logger } from '../logger';
import { readFileSync, writeFileSync, existsSync } from 'fs';

export class RollbackManager {
  private backupPath: string;
  private logger: Logger;

  constructor(backupPath: string, logger: Logger) {
    this.backupPath = backupPath;
    this.logger = logger;
  }

  // Create backup before migration
  async createBackup(configPath: string): Promise<BackupResult> {
    try {
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupFile = `${this.backupPath}/backup-${timestamp}.json`;

      if (!existsSync(configPath)) {
        throw new Error(`Config file not found: ${configPath}`);
      }

      const config = readFileSync(configPath, 'utf-8');
      writeFileSync(backupFile, config, 'utf-8');

      this.logger.info('Backup created', {
        originalPath: configPath,
        backupPath: backupFile,
      });

      return {
        success: true,
        backupPath: backupFile,
        timestamp,
      };

    } catch (error) {
      this.logger.error('Backup creation failed', {
        error: error.message,
        configPath,
      });

      return {
        success: false,
        error: error.message,
      };
    }
  }

  // Rollback to previous configuration
  async rollback(configPath: string, backupPath: string): Promise<RollbackResult> {
    try {
      if (!existsSync(backupPath)) {
        throw new Error(`Backup file not found: ${backupPath}`);
      }

      const backupConfig = readFileSync(backupPath, 'utf-8');
      writeFileSync(configPath, backupConfig, 'utf-8');

      this.logger.info('Rollback completed', {
        configPath,
        backupPath,
      });

      return {
        success: true,
        restoredFrom: backupPath,
      };

    } catch (error) {
      this.logger.error('Rollback failed', {
        error: error.message,
        configPath,
        backupPath,
      });

      return {
        success: false,
        error: error.message,
      };
    }
  }

  // List available backups
  listBackups(): BackupInfo[] {
    // Implementation would scan backup directory
    return [];
  }
}

interface BackupResult {
  success: boolean;
  backupPath?: string;
  timestamp?: string;
  error?: string;
}

interface RollbackResult {
  success: boolean;
  restoredFrom?: string;
  error?: string;
}

interface BackupInfo {
  path: string;
  timestamp: string;
  size: number;
}
```

### Migration Validator
```typescript
import { Logger } from '../logger';

export class MigrationValidator {
  constructor(private logger: Logger) {}

  // Validate migrated configuration
  async validateMigration(
    originalConfig: EventSidekickConfig,
    migratedConfig: C15TConfig
  ): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    try {
      // Check destination count
      if (originalConfig.destinations.length !== migratedConfig.analytics.destinations.length) {
        warnings.push(
          `Destination count mismatch: ${originalConfig.destinations.length} -> ${migratedConfig.analytics.destinations.length}`
        );
      }

      // Validate each migrated destination
      for (const migratedDest of migratedConfig.analytics.destinations) {
        const validation = await this.validateDestination(migratedDest);
        if (!validation.valid) {
          errors.push(...validation.errors);
        }
        warnings.push(...validation.warnings);
      }

      // Check consent configuration
      if (originalConfig.consent && !migratedConfig.consent) {
        warnings.push('Consent configuration was not migrated');
      }

      return {
        valid: errors.length === 0,
        errors,
        warnings,
      };

    } catch (error) {
      this.logger.error('Migration validation failed', {
        error: error.message,
      });

      return {
        valid: false,
        errors: [error.message],
        warnings: [],
      };
    }
  }

  private async validateDestination(
    dest: C15TConfig['analytics']['destinations'][0]
  ): Promise<ValidationResult> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check required fields
    if (!dest.type) {
      errors.push('Destination type is required');
    }

    if (!dest.settings) {
      errors.push('Destination settings are required');
    }

    if (!dest.requiredConsent || dest.requiredConsent.length === 0) {
      warnings.push(`No consent requirements specified for ${dest.type}`);
    }

    // Validate destination-specific settings
    switch (dest.type) {
      case 'posthog':
        if (!dest.settings.apiKey) {
          errors.push('PostHog API key is required');
        }
        break;
      case 'meta-pixel':
        if (!dest.settings.pixelId) {
          errors.push('Meta Pixel ID is required');
        }
        if (!dest.settings.accessToken) {
          errors.push('Meta Pixel access token is required');
        }
        break;
      case 'google-analytics':
        if (!dest.settings.measurementId) {
          errors.push('Google Analytics measurement ID is required');
        }
        if (!dest.settings.apiSecret) {
          errors.push('Google Analytics API secret is required');
        }
        break;
    }

    return {
      valid: errors.length === 0,
      errors,
      warnings,
    };
  }
}
```

### Usage Examples
```typescript
// CLI migration tool
import { EventSidekickMigrator } from './migrate-event-sidekick';

async function runMigration() {
  const migrator = new EventSidekickMigrator();
  
  // Migrate to self-hosted configuration
  const result = await migrator.migrateConfig(
    './event-sidekick-config.json',
    './c15t-config.json',
    {
      targetType: 'self-hosted',
    }
  );

  if (result.success) {
    console.log('Migration completed successfully!');
    console.log(`Migrated ${result.report?.destinationsMigrated} destinations`);
  } else {
    console.error('Migration failed:', result.error);
  }
}

// Consent.io migration
const consentIoResult = await migrator.migrateConfig(
  './event-sidekick-config.json',
  './c15t-consent-io-config.json',
  {
    targetType: 'consent-io',
    organizationId: 'org-123',
    environment: 'production',
  }
);
```

## üß™ Testing Requirements
- Unit tests for migration script
- Unit tests for compatibility layer
- Feature flag tests
- Rollback tests
- Migration validation tests
- Integration tests with event-sidekick
- A/B testing tests

## üîç Definition of Done
- [ ] Migration script for event-sidekick configs created
- [ ] Compatibility layer for existing APIs created
- [ ] Feature flags for gradual rollout added
- [ ] Rollback capabilities implemented
- [ ] Migration validation added
- [ ] Support for both consent.io and self-hosted migrations
- [ ] Unit tests for migration tools
- [ ] Code review completed

## üìö Related Documentation
- [Analytics Migration Index](../docs/analytics-migration-index.md)
- [Analytics Migration Summary](../docs/analytics-migration-summary.md)

## üîó Dependencies
- [4.1: Integrate with Existing Consent System](./18-consent-integration.md) ‚úÖ

## üöÄ Next Ticket
[4.3: Update Frontend Consent Flow](./20-frontend-consent-flow.md)
