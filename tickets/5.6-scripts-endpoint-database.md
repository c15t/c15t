# Ticket 5.6: Scripts Endpoint Database

## üìã Ticket Details
**Phase**: 5 - Consent.io Control Plane  
**Story Points**: 2  
**Priority**: High  
**Assignee**: TBD  
**Status**: Ready

## üîó Dependencies
**Depends on**: Ticket 5.4 (Database Loading)  
**Blocking**: None  

## üéØ Description
Update scripts endpoint to generate scripts dynamically from database destinations for consent.io deployed instances. Scripts are not stored in the database but generated on-demand from destination configurations and passed as config to the c15tBackendInstance.

## üß† Context & Background
This ticket updates the scripts endpoint for the **consent.io control plane** where:

- **Scripts are generated dynamically** from database destination configurations
- **No script storage** - scripts are created on-demand from destination settings
- **Organization-aware** script generation based on database destinations
- **Environment-aware** script generation (dev/staging/production)
- **Self-hosted users** continue using direct configuration with `c15tInstance`
- **Two deployment models** coexist:
  - **Consent.io SaaS**: Database Destinations ‚Üí Generated Scripts ‚Üí c15tBackendInstance
  - **Self-hosted**: Direct Config ‚Üí c15tInstance

The scripts endpoint must:
- Query database destinations by organization and environment
- Generate scripts dynamically from destination configurations
- Pass generated scripts as config to c15tBackendInstance
- Cache generated scripts for performance
- Handle missing or invalid configurations gracefully

## ‚úÖ Acceptance Criteria
- [ ] Update scripts handler to query database destinations
- [ ] Generate scripts dynamically from destination configs
- [ ] Add organization-aware script generation
- [ ] Add environment-aware script generation
- [ ] Pass scripts as config to c15tBackendInstance
- [ ] Add caching for performance
- [ ] Add error handling
- [ ] Unit tests for database integration

## üìÅ Files to Modify
- `packages/backend/src/v2/handlers/analytics/scripts.handler.ts`

## üîß Implementation Details

### Enhanced Scripts Handler
```typescript
import { Request, Response } from 'express';
import { DestinationRepository } from '../../db/repositories/destination.repository';
import { SettingsEncryption } from '../../utils/settings-encryption';
import { DestinationManager } from '../../analytics/destination-manager';
import { AnalyticsConsent, Script } from '../../analytics/types';
import { Logger } from '../../logger';

interface DatabaseScriptsOptions {
  organizationId: string;
  environment: 'development' | 'staging' | 'production';
  databaseUrl: string;
  databaseEncryptionKey: string;
}

export class DatabaseScriptsHandler {
  private cache = new Map<string, { scripts: Script[]; timestamp: number }>();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes

  constructor(
    private destinationRepository: DestinationRepository,
    private settingsEncryption: SettingsEncryption,
    private destinationManager: DestinationManager,
    private logger: Logger
  ) {}

  async getScriptsFromDatabase(
    req: Request,
    res: Response,
    options: DatabaseScriptsOptions
  ): Promise<void> {
    try {
      const { consent: consentString } = req.query;
      
      if (!consentString) {
        res.status(400).json({
          error: 'Missing consent parameter',
          message: 'Consent preferences are required',
        });
        return;
      }

      // Parse consent
      const consent: AnalyticsConsent = JSON.parse(consentString as string);
      
      // Generate cache key
      const cacheKey = `${options.organizationId}-${options.environment}-${JSON.stringify(consent)}`;
      
      // Check cache first
      const cached = this.cache.get(cacheKey);
      if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
        this.logger.debug('Returning cached scripts', {
          organizationId: options.organizationId,
          environment: options.environment,
          scriptCount: cached.scripts.length,
        });
        
        res.json({
          scripts: cached.scripts,
          metadata: {
            generatedAt: new Date(cached.timestamp).toISOString(),
            consent,
            destinationCount: cached.scripts.length,
            cached: true,
          },
        });
        return;
      }

      // Query destinations from database
      const destinations = await this.destinationRepository.findByOrganization(
        options.organizationId,
        options.environment
      );

      // Filter enabled destinations
      const enabledDestinations = destinations.filter(dest => 
        dest.enabled && 
        !dest.deletedAt &&
        dest.requiredConsent.every(purpose => consent[purpose])
      );

      // Generate scripts from destinations
      const scripts = await this.generateScriptsFromDestinations(
        enabledDestinations,
        consent
      );

      // Cache the results
      this.cache.set(cacheKey, {
        scripts,
        timestamp: Date.now(),
      });

      this.logger.info('Generated scripts from database destinations', {
        organizationId: options.organizationId,
        environment: options.environment,
        totalDestinations: destinations.length,
        enabledDestinations: enabledDestinations.length,
        generatedScripts: scripts.length,
      });

      res.json({
        scripts,
        metadata: {
          generatedAt: new Date().toISOString(),
          consent,
          destinationCount: scripts.length,
          cached: false,
        },
      });

    } catch (error) {
      this.logger.error('Failed to generate scripts from database', {
        error: error.message,
        organizationId: options.organizationId,
        environment: options.environment,
      });

      res.status(500).json({
        error: 'Internal server error',
        message: 'Failed to generate scripts from database',
      });
    }
  }

  private async generateScriptsFromDestinations(
    destinations: any[],
    consent: AnalyticsConsent
  ): Promise<Script[]> {
    const scripts: Script[] = [];

    for (const destination of destinations) {
      try {
        // Decrypt settings
        const settings = destination.settingsEncrypted 
          ? this.settingsEncryption.decrypt(destination.settings as any)
          : destination.settings;

        // Create destination instance
        const destinationInstance = await this.destinationManager.createDestinationInstance(
          destination.type,
          settings
        );

        // Check if destination supports script generation
        if (!destinationInstance.hasClientScript || !destinationInstance.generateScript) {
          continue;
        }

        // Generate scripts
        const generatedScripts = await destinationInstance.generateScript(settings, consent);
        
        if (generatedScripts) {
          const scriptArray = Array.isArray(generatedScripts) ? generatedScripts : [generatedScripts];
          scripts.push(...scriptArray);
          
          this.logger.debug('Generated scripts for destination', {
            destinationType: destination.type,
            scriptCount: scriptArray.length,
          });
        }

      } catch (error) {
        this.logger.error('Failed to generate scripts for destination', {
          destinationType: destination.type,
          destinationId: destination.id,
          error: error.message,
        });
        // Continue with other destinations
      }
    }

    return scripts;
  }

  // Clear cache for organization/environment
  clearCache(organizationId: string, environment: string): void {
    const keysToDelete = Array.from(this.cache.keys()).filter(key => 
      key.startsWith(`${organizationId}-${environment}-`)
    );
    
    keysToDelete.forEach(key => this.cache.delete(key));
    
    this.logger.debug('Cleared scripts cache', { organizationId, environment });
  }
}
```

### c15tBackendInstance Integration
```typescript
// Enhanced c15tBackendInstance for consent.io deployed instances
export async function createC15TBackendInstance(options: {
  organizationId: string;
  environment: 'development' | 'staging' | 'production';
  databaseUrl: string;
  databaseEncryptionKey: string;
  scriptsEndpoint?: string;
}): Promise<C15TContext> {
  const logger = new Logger({ component: 'c15t-backend' });
  
  try {
    logger.info('Creating c15t backend instance', {
      organizationId: options.organizationId,
      environment: options.environment,
    });

    // Initialize database components
    const destinationRepository = new DestinationRepository(options.databaseUrl);
    const settingsEncryption = new SettingsEncryption(options.databaseEncryptionKey);
    
    // Initialize core components
    const eventProcessor = new EventProcessor(logger);
    const destinationManager = new DestinationManager(destinationRegistry, logger);
    
    // Load destinations from database
    const destinations = await destinationRepository.findByOrganization(
      options.organizationId,
      options.environment
    );
    
    const enabledDestinations = destinations.filter(dest => dest.enabled && !dest.deletedAt);
    
    // Convert database destinations to DestinationConfig format
    const destinationConfigs = await Promise.all(
      enabledDestinations.map(async (dest) => {
        try {
          const settings = dest.settingsEncrypted 
            ? settingsEncryption.decrypt(dest.settings as any)
            : dest.settings;

          return {
            type: dest.type,
            enabled: dest.enabled,
            settings,
            requiredConsent: dest.requiredConsent,
          };
        } catch (error) {
          logger.error('Failed to decrypt destination settings', {
            destinationId: dest.id,
            error: error.message,
          });
          return null;
        }
      })
    );

    // Filter out failed decryptions
    const validConfigs = destinationConfigs.filter((config): config is DestinationConfig => config !== null);
    
    // Load destinations into manager
    if (validConfigs.length > 0) {
      await destinationManager.loadDestinations(validConfigs);
    }

    // Create enhanced scripts handler
    const scriptsHandler = new DatabaseScriptsHandler(
      destinationRepository,
      settingsEncryption,
      destinationManager,
      logger
    );

    // Create context with database-aware handlers
    const context: C15TContext = {
      destinationManager,
      eventProcessor,
      logger,
      handlers: {
        processEvents: (req, res) => processEventsHandler(req, res, {
          eventProcessor,
          destinationManager,
          logger,
        }),
        getScripts: (req, res) => scriptsHandler.getScriptsFromDatabase(req, res, {
          organizationId: options.organizationId,
          environment: options.environment,
          databaseUrl: options.databaseUrl,
          databaseEncryptionKey: options.databaseEncryptionKey,
        }),
      },
      utils: {
        getDestinationStatus: (type: string) => destinationManager.getDestinationStatus(type),
        testDestination: (type: string) => destinationManager.testDestination(type),
        getLoadedDestinations: () => destinationManager.getLoadedDestinations(),
        clearScriptsCache: () => scriptsHandler.clearCache(options.organizationId, options.environment),
      },
    };

    logger.info('c15t backend instance created successfully', {
      organizationId: options.organizationId,
      environment: options.environment,
      loadedDestinations: validConfigs.length,
    });

    return context;

  } catch (error) {
    logger.error('Failed to create c15t backend instance', {
      error: error.message,
      organizationId: options.organizationId,
      environment: options.environment,
    });
    throw new Error(`Failed to create c15t backend instance: ${error.message}`);
  }
}
```

### Usage Examples
```typescript
// Consent.io deployed instance (loads from database, generates scripts dynamically)
const backendInstance = await createC15TBackendInstance({
  organizationId: 'org-123',
  environment: 'production',
  databaseUrl: process.env.DATABASE_URL,
  databaseEncryptionKey: process.env.ENCRYPTION_KEY,
});

// Scripts are generated dynamically from database destinations
app.get('/analytics/scripts', backendInstance.handlers.getScripts);

// Self-hosted instance (direct configuration)
const instance = await c15tInstance({
  analytics: {
    destinations: [
      posthog({ apiKey: 'phc_xxx' }),
      metaPixel({ pixelId: '123', accessToken: 'token' }),
    ],
  },
});
```

### Self-Hosted Integration Note
```typescript
// For self-hosted users, they continue using direct configuration:
// Scripts are generated from direct destination configs, not database

// Self-hosted example:
const instance = await c15tInstance({
  analytics: {
    destinations: [
      posthog({ apiKey: 'phc_their_key' }),
      metaPixel({ pixelId: '123', accessToken: 'their_token' }),
    ],
  },
});

// Consent.io deployed instances generate scripts dynamically from database destinations
```

## üß™ Testing Requirements
- Unit tests for database integration
- Organization filtering tests
- Environment filtering tests
- Script generation tests
- Caching tests
- Error handling tests
- Performance tests

## üîç Definition of Done
- [ ] Scripts handler queries database destinations
- [ ] Scripts generated dynamically from destination configs
- [ ] Organization-aware script generation
- [ ] Environment-aware script generation
- [ ] Scripts passed as config to c15tBackendInstance
- [ ] Caching for performance added
- [ ] Error handling implemented
- [ ] Unit tests for database integration
- [ ] Code review completed

## üìö Related Documentation
- [Cloud Configuration](../docs/analytics-cloud-configuration.md)
- [Universal Destinations](../docs/analytics-universal-destinations.md)

## üîó Dependencies
- [3.1: Database Schema](./12-database-schema.md) ‚úÖ
- [3.2: Admin API Contracts](./13-admin-api-contracts.md) ‚úÖ
- [3.3: Admin API Handlers](./14-admin-api-handlers.md) ‚úÖ
- [3.4: Database Loading Support](./15-database-loading.md) ‚úÖ
- [3.5: Admin UI Components](./16-admin-ui-components.md) ‚úÖ

## üöÄ Next Phase
[Phase 4: Unified Consent & Migration](../docs/epic-phase-4-unified-consent.md)

## üéØ Phase 3 Complete
Once this ticket is done, Phase 3 is complete! You should have:
- ‚úÖ Cloud-configurable destinations with admin UI
- ‚úÖ Database-driven destination management
- ‚úÖ Dynamic script generation from database configs
- ‚úÖ Admin UI functional
- ‚úÖ All tests passing
