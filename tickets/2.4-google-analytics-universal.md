# Ticket 2.4: Google Analytics Universal Destination

## üìã Ticket Details
**Phase**: 2 - Universal Destinations  
**Story Points**: 5  
**Priority**: High  
**Assignee**: TBD  
**Status**: Ready

## üîó Dependencies
**Depends on**: Ticket 2.1 (Universal Destination Interface), Ticket 2.2 (Scripts Endpoint)  
**Blocking**: None  

## üéØ Description
Implement Google Analytics 4 with both server-side Measurement Protocol calls and client-side gtag.js script generation. This universal destination enables comprehensive web analytics with full GDPR compliance.

## üß† Context & Background
Google Analytics 4 is the standard for web analytics. This universal destination must:
- **Server-side**: Send events to GA4 Measurement Protocol for accurate tracking
- **Client-side**: Generate gtag.js scripts for browser-based analytics
- **GDPR compliance**: Only track when measurement consent is granted
- **Event mapping**: Convert analytics events to GA4 events
- **Enhanced measurement**: Support automatic event collection
- **Error handling**: Gracefully handle API failures and rate limits

The destination integrates with:
- GA4 Measurement Protocol for server-side events
- gtag.js for client-side tracking
- Consent management for GDPR compliance
- Event processor for data transformation

## ‚úÖ Acceptance Criteria
- [ ] Create `GoogleAnalyticsDestination` class
- [ ] Implement server-side Measurement Protocol
- [ ] Implement client-side gtag.js script generation
- [ ] Add Zod validation for settings
- [ ] Add connection testing
- [ ] Handle consent requirements (measurement)
- [ ] Unit tests for both server and client
- [ ] Integration tests with GA4 APIs

## üìÅ Files to Create
- `packages/destinations/src/google-analytics.ts`
- `packages/destinations/src/google-analytics.test.ts`

## üîß Implementation Details

### Settings Schema
```typescript
import { z } from 'zod';

export const GoogleAnalyticsSettingsSchema = z.object({
  measurementId: z.string().min(1, 'Measurement ID is required'),
  apiSecret: z.string().min(1, 'API Secret is required'),
  enableServerSide: z.boolean().default(true),
  enableClientSide: z.boolean().default(true),
  enableEnhancedMeasurement: z.boolean().default(true),
  anonymizeIp: z.boolean().default(true),
  cookieFlags: z.string().default('SameSite=None;Secure'),
  customParameters: z.record(z.string()).optional(),
  debugMode: z.boolean().default(false),
});

export type GoogleAnalyticsSettings = z.infer<typeof GoogleAnalyticsSettingsSchema>;
```

### Google Analytics Destination Implementation
```typescript
import { UniversalDestinationPlugin } from '../types';
import { GoogleAnalyticsSettings, GoogleAnalyticsSettingsSchema } from './google-analytics-settings';
import { AnalyticsEvent, EventContext, Script } from '../types';

export class GoogleAnalyticsDestination implements UniversalDestinationPlugin<GoogleAnalyticsSettings> {
  readonly type = 'google-analytics';
  readonly version = '1.0.0';
  readonly gdprCompliant = true;
  readonly settingsSchema = GoogleAnalyticsSettingsSchema;
  readonly requiredConsent: ReadonlyArray<ConsentPurpose> = ['measurement'];
  readonly hasClientScript = true;

  private settings: GoogleAnalyticsSettings | null = null;
  private logger: Logger;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  async initialize(settings: GoogleAnalyticsSettings): Promise<void> {
    this.settings = GoogleAnalyticsSettingsSchema.parse(settings);
    this.logger.info('Google Analytics destination initialized', { 
      measurementId: this.settings.measurementId,
      enableServerSide: this.settings.enableServerSide,
      enableClientSide: this.settings.enableClientSide,
      enableEnhancedMeasurement: this.settings.enableEnhancedMeasurement,
    });
  }

  async testConnection(): Promise<boolean> {
    if (!this.settings) {
      throw new Error('Google Analytics destination not initialized');
    }

    try {
      // Test Measurement Protocol connection
      const testEvent = {
        client_id: 'test-client-id',
        events: [{
          name: 'test_event',
          params: {
            test: true,
            timestamp_micros: Date.now() * 1000,
          },
        }],
      };

      const response = await fetch(
        `https://www.google-analytics.com/mp/collect?measurement_id=${this.settings.measurementId}&api_secret=${this.settings.apiSecret}`,
        {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(testEvent),
        }
      );

      return response.ok;
    } catch (error) {
      this.logger.error('Google Analytics connection test failed', { error: error.message });
      return false;
    }
  }

  async track(event: TrackEvent, context: EventContext): Promise<void> {
    if (!this.settings?.enableServerSide) return;
    if (!context.consent.measurement) return;

    try {
      const ga4Event = this.mapTrackEvent(event, context);
      await this.sendToMeasurementProtocol(ga4Event);
    } catch (error) {
      this.logger.error('Failed to send track event to Google Analytics', {
        error: error.message,
        event: event.event,
      });
    }
  }

  async page(event: PageEvent, context: EventContext): Promise<void> {
    if (!this.settings?.enableServerSide) return;
    if (!context.consent.measurement) return;

    try {
      const ga4Event = this.mapPageEvent(event, context);
      await this.sendToMeasurementProtocol(ga4Event);
    } catch (error) {
      this.logger.error('Failed to send page event to Google Analytics', {
        error: error.message,
        page: event.name,
      });
    }
  }

  async identify(event: IdentifyEvent, context: EventContext): Promise<void> {
    if (!this.settings?.enableServerSide) return;
    if (!context.consent.measurement) return;

    try {
      const ga4Event = this.mapIdentifyEvent(event, context);
      await this.sendToMeasurementProtocol(ga4Event);
    } catch (error) {
      this.logger.error('Failed to send identify event to Google Analytics', {
        error: error.message,
        userId: event.userId,
      });
    }
  }

  generateScript(settings: GoogleAnalyticsSettings, consent: AnalyticsConsent): Script[] | null {
    if (!settings.enableClientSide) return null;
    if (!consent.measurement) return null;

    return [
      {
        type: 'external',
        src: 'https://www.googletagmanager.com/gtag/js',
        async: true,
        requiredConsent: ['measurement'],
        name: 'Google Analytics Core',
      },
      {
        type: 'inline',
        content: `
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', '${settings.measurementId}', {
            'anonymize_ip': ${settings.anonymizeIp},
            'cookie_flags': '${settings.cookieFlags}',
            'send_page_view': ${settings.enableEnhancedMeasurement},
            ${settings.debugMode ? "'debug_mode': true," : ''}
            ${settings.customParameters ? `'custom_map': ${JSON.stringify(settings.customParameters)},` : ''}
          });
          ${settings.debugMode ? "gtag('event', 'debug_mode', { debug_mode: true });" : ''}
        `,
        requiredConsent: ['measurement'],
        name: 'Google Analytics Config',
      },
    ];
  }

  getScriptDependencies(): string[] {
    return ['Google Analytics Core'];
  }

  // Private methods
  private async sendToMeasurementProtocol(event: any): Promise<void> {
    if (!this.settings) return;

    const response = await fetch(
      `https://www.google-analytics.com/mp/collect?measurement_id=${this.settings.measurementId}&api_secret=${this.settings.apiSecret}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(event),
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`GA4 Measurement Protocol error: ${response.status} ${error}`);
    }

    this.logger.debug('Google Analytics event sent successfully', { 
      eventName: event.events?.[0]?.name,
    });
  }

  private mapTrackEvent(event: TrackEvent, context: EventContext): any {
    return {
      client_id: context.sessionId,
      user_id: context.userId,
      events: [{
        name: this.mapEventName(event.event),
        params: {
          ...this.mapEventParameters(event.properties),
          ...this.settings?.customParameters,
          timestamp_micros: event.timestamp.getTime() * 1000,
        },
      }],
    };
  }

  private mapPageEvent(event: PageEvent, context: EventContext): any {
    return {
      client_id: context.sessionId,
      user_id: context.userId,
      events: [{
        name: 'page_view',
        params: {
          page_title: event.name,
          page_location: event.url,
          page_path: new URL(event.url).pathname,
          ...this.settings?.customParameters,
          timestamp_micros: event.timestamp.getTime() * 1000,
        },
      }],
    };
  }

  private mapIdentifyEvent(event: IdentifyEvent, context: EventContext): any {
    return {
      client_id: context.sessionId,
      user_id: event.userId,
      user_properties: this.mapUserProperties(event.traits),
      events: [{
        name: 'user_engagement',
        params: {
          engagement_time_msec: 1000,
          ...this.settings?.customParameters,
          timestamp_micros: event.timestamp.getTime() * 1000,
        },
      }],
    };
  }

  private mapEventName(eventName: string): string {
    // Map common analytics events to GA4 events
    const eventMap: Record<string, string> = {
      'Product Viewed': 'view_item',
      'Product Added to Cart': 'add_to_cart',
      'Checkout Started': 'begin_checkout',
      'Purchase': 'purchase',
      'Sign Up': 'sign_up',
      'Login': 'login',
      'Search': 'search',
      'Video Play': 'video_play',
      'Download': 'file_download',
    };

    return eventMap[eventName] || eventName.toLowerCase().replace(/\s+/g, '_');
  }

  private mapEventParameters(properties: Record<string, unknown>): Record<string, unknown> {
    const params: Record<string, unknown> = {};

    // Map common e-commerce properties
    if (properties.value) {
      params.value = properties.value;
      params.currency = properties.currency || 'USD';
    }

    if (properties.category) {
      params.item_category = properties.category;
    }

    if (properties.product_id) {
      params.item_id = properties.product_id;
    }

    if (properties.product_name) {
      params.item_name = properties.product_name;
    }

    if (properties.quantity) {
      params.quantity = properties.quantity;
    }

    // Map custom properties
    Object.entries(properties).forEach(([key, value]) => {
      if (!['value', 'currency', 'category', 'product_id', 'product_name', 'quantity'].includes(key)) {
        params[key] = value;
      }
    });

    return params;
  }

  private mapUserProperties(traits: Record<string, unknown>): Record<string, any> {
    const userProperties: Record<string, any> = {};

    Object.entries(traits).forEach(([key, value]) => {
      // GA4 user properties have specific formatting requirements
      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
        userProperties[key] = { value };
      }
    });

    return userProperties;
  }
}
```

### Event Mapping Examples
```typescript
// Common GA4 event mappings
const GA4_EVENT_MAPPINGS = {
  // E-commerce events
  'Product Viewed': 'view_item',
  'Product Added to Cart': 'add_to_cart',
  'Checkout Started': 'begin_checkout',
  'Purchase': 'purchase',
  
  // User lifecycle events
  'Sign Up': 'sign_up',
  'Login': 'login',
  'Logout': 'logout',
  
  // Engagement events
  'Search': 'search',
  'Video Play': 'video_play',
  'Video Complete': 'video_complete',
  'Download': 'file_download',
  
  // Custom events
  'Newsletter Signup': 'sign_up',
  'Contact Form Submit': 'form_submit',
  'Button Click': 'click',
};

// Enhanced measurement events
const ENHANCED_MEASUREMENT_EVENTS = [
  'page_view',
  'scroll',
  'outbound_click',
  'site_search',
  'video_engagement',
  'file_download',
];

// Custom parameter mapping
function mapCustomParameters(properties: Record<string, unknown>): Record<string, unknown> {
  const params: Record<string, unknown> = {};
  
  // Map common e-commerce parameters
  if (properties.order_id) {
    params.transaction_id = properties.order_id;
  }
  
  if (properties.revenue) {
    params.value = properties.revenue;
    params.currency = properties.currency || 'USD';
  }
  
  if (properties.items) {
    params.items = properties.items;
  }
  
  // Map custom parameters
  Object.entries(properties).forEach(([key, value]) => {
    if (!['order_id', 'revenue', 'currency', 'items'].includes(key)) {
      params[key] = value;
    }
  });
  
  return params;
}
```

### Error Handling
```typescript
// Google Analytics specific error types
export class GoogleAnalyticsError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode?: number
  ) {
    super(message);
    this.name = 'GoogleAnalyticsError';
  }
}

export class MeasurementProtocolError extends GoogleAnalyticsError {
  constructor(message: string, statusCode: number) {
    super(message, 'MEASUREMENT_PROTOCOL_ERROR', statusCode);
  }
}

export class GtagScriptError extends GoogleAnalyticsError {
  constructor(message: string) {
    super(message, 'GTAG_SCRIPT_ERROR');
  }
}

// Error handling in destination
private async handleAPIError(error: any, event: any): Promise<void> {
  if (error.status === 429) {
    // Rate limit - implement exponential backoff
    this.logger.warn('Google Analytics rate limit exceeded', { event });
    throw new MeasurementProtocolError('Rate limit exceeded', 429);
  }
  
  if (error.status >= 400 && error.status < 500) {
    // Client error - don't retry
    this.logger.error('Google Analytics client error', { 
      status: error.status, 
      event,
      error: error.message 
    });
    throw new MeasurementProtocolError('Client error', error.status);
  }
  
  // Server error - retryable
  this.logger.error('Google Analytics server error', { 
    status: error.status, 
    event,
    error: error.message 
  });
  throw new MeasurementProtocolError('Server error', error.status);
}
```

## üß™ Testing Requirements
- Unit tests for Google Analytics destination
- Integration tests with GA4 Measurement Protocol
- Script generation tests
- Consent filtering tests
- Error handling tests
- Event mapping tests
- Connection testing tests
- Enhanced measurement tests

## üîç Definition of Done
- [ ] Google Analytics destination sends events to Measurement Protocol
- [ ] Client-side gtag.js script generated
- [ ] Settings validated with Zod schema
- [ ] Connection testing implemented
- [ ] Measurement consent requirement handled
- [ ] Unit tests for both server and client
- [ ] Integration tests with GA4 APIs
- [ ] Code review completed

## üìö Related Documentation
- [Universal Destinations](../docs/analytics-universal-destinations.md)
- [Analytics Destination Packages Strategy](../docs/analytics-destination-packages-strategy.md)

## üîó Dependencies
- [2.1: Universal Destination Interface](./07-universal-destination-interface.md) ‚úÖ
- [2.2: Scripts Endpoint](./08-scripts-endpoint.md) ‚úÖ
- [2.3: Meta Pixel Universal Destination](./09-meta-pixel-universal.md) ‚úÖ

## üöÄ Next Ticket
[2.5: Frontend Integration](./11-frontend-integration.md)
