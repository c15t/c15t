# Ticket 5.3: Consent Backend API Handlers

## üìã Ticket Details
**Phase**: 5 - Consent.io Control Plane  
**Story Points**: 5  
**Priority**: High  
**Assignee**: TBD  
**Status**: Ready

## üîó Dependencies
**Depends on**: Ticket 5.2 (Consent Backend API Contracts)  
**Blocking**: Ticket 5.5 (Consent Dashboard UI Components)  

## üéØ Description
Build CRUD handlers for destination management in the consent.io control plane. These handlers power the consent dashboard where organizations manage their analytics destinations, while self-hosted users continue using direct code configuration.

## üß† Context & Background
This ticket implements the backend handlers for the **consent.io control plane** dashboard where:

- **Organizations** manage destinations through web UI instead of code
- **API handlers** process CRUD operations for destinations
- **Settings encryption** protects sensitive API keys and tokens
- **Hot-reload** updates deployed instances when configs change
- **Self-hosted users** continue using `c15tInstance` with direct configuration

The handlers must:
- Process CRUD operations for destinations
- Encrypt/decrypt sensitive settings
- Validate destination configurations
- Test connections to external services
- Support hot-reload for deployed instances
- Maintain audit trails

## ‚úÖ Acceptance Criteria
- [ ] Implement create destination handler
- [ ] Implement list destinations handler
- [ ] Implement get destination handler
- [ ] Implement update destination handler
- [ ] Implement delete destination handler
- [ ] Implement test connection handler
- [ ] Add settings encryption/decryption
- [ ] Add hot-reload support
- [ ] Unit tests for all handlers

## üìÅ Files to Create
- `packages/backend/src/v2/handlers/admin/destinations.handler.ts`
- `packages/backend/src/v2/handlers/admin/destinations.handler.test.ts`

## üîß Implementation Details

### Handler Implementation
```typescript
import { Request, Response } from 'express';
import { DestinationRepository } from '../../db/repositories/destination.repository';
import { SettingsEncryption } from '../../utils/settings-encryption';
import { DestinationValidator, ApiErrorHandler } from '../../contracts/admin/destinations';
import { Logger } from '../../logger';
import { DestinationManager } from '../../analytics/destination-manager';

export class DestinationHandlers {
  constructor(
    private destinationRepository: DestinationRepository,
    private settingsEncryption: SettingsEncryption,
    private destinationManager: DestinationManager,
    private logger: Logger
  ) {}

  // Create destination
  async createDestination(req: Request, res: Response): Promise<void> {
    try {
      const organizationId = req.user.organizationId;
      const userId = req.user.id;

      // Validate request
      const validatedData = DestinationValidator.validateCreateDestination(req.body);
      
      // Encrypt sensitive settings
      const encryptedSettings = this.settingsEncryption.encrypt(validatedData.settings);
      
      // Create destination
      const destination = await this.destinationRepository.create({
        organizationId,
        type: validatedData.type,
        name: validatedData.name,
        description: validatedData.description,
        environment: validatedData.environment,
        settings: encryptedSettings,
        settingsEncrypted: true,
        requiredConsent: validatedData.requiredConsent,
        enabled: validatedData.enabled,
        testMode: validatedData.testMode,
        createdBy: userId,
      });

      // Test connection if enabled
      if (destination.enabled) {
        await this.testDestinationConnection(destination.id);
      }

      // Trigger hot-reload for deployed instances
      await this.triggerHotReload(organizationId, destination.environment);

      this.logger.info('Destination created', {
        destinationId: destination.id,
        organizationId,
        type: destination.type,
        environment: destination.environment,
      });

      res.status(201).json(destination);
    } catch (error) {
      if (error instanceof z.ZodError) {
        const apiError = ApiErrorHandler.createValidationError(error);
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      this.logger.error('Failed to create destination', {
        error: error.message,
        organizationId: req.user.organizationId,
      });

      res.status(500).json({
        error: 'INTERNAL_ERROR',
        message: 'Failed to create destination',
        statusCode: 500,
      });
    }
  }

  // List destinations
  async listDestinations(req: Request, res: Response): Promise<void> {
    try {
      const organizationId = req.user.organizationId;
      const {
        page = 1,
        limit = 20,
        environment,
        type,
        enabled,
      } = req.query;

      const destinations = await this.destinationRepository.findByOrganization(
        organizationId,
        environment as string
      );

      // Filter by type and enabled status
      let filteredDestinations = destinations;
      if (type) {
        filteredDestinations = filteredDestinations.filter(d => d.type === type);
      }
      if (enabled !== undefined) {
        const enabledBool = enabled === 'true';
        filteredDestinations = filteredDestinations.filter(d => d.enabled === enabledBool);
      }

      // Paginate results
      const startIndex = (Number(page) - 1) * Number(limit);
      const endIndex = startIndex + Number(limit);
      const paginatedDestinations = filteredDestinations.slice(startIndex, endIndex);

      // Decrypt settings for response
      const destinationsWithDecryptedSettings = paginatedDestinations.map(dest => ({
        ...dest,
        settings: dest.settingsEncrypted 
          ? this.settingsEncryption.decrypt(dest.settings as any)
          : dest.settings,
      }));

      res.json({
        destinations: destinationsWithDecryptedSettings,
        total: filteredDestinations.length,
        page: Number(page),
        limit: Number(limit),
      });
    } catch (error) {
      this.logger.error('Failed to list destinations', {
        error: error.message,
        organizationId: req.user.organizationId,
      });

      res.status(500).json({
        error: 'INTERNAL_ERROR',
        message: 'Failed to list destinations',
        statusCode: 500,
      });
    }
  }

  // Get destination by ID
  async getDestination(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const organizationId = req.user.organizationId;

      const destination = await this.destinationRepository.findById(id);
      
      if (!destination) {
        const apiError = ApiErrorHandler.createNotFoundError('Destination', id);
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      // Check organization access
      if (destination.organizationId !== organizationId) {
        const apiError = ApiErrorHandler.createForbiddenError();
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      // Decrypt settings for response
      const destinationWithDecryptedSettings = {
        ...destination,
        settings: destination.settingsEncrypted 
          ? this.settingsEncryption.decrypt(destination.settings as any)
          : destination.settings,
      };

      res.json(destinationWithDecryptedSettings);
    } catch (error) {
      this.logger.error('Failed to get destination', {
        error: error.message,
        destinationId: req.params.id,
        organizationId: req.user.organizationId,
      });

      res.status(500).json({
        error: 'INTERNAL_ERROR',
        message: 'Failed to get destination',
        statusCode: 500,
      });
    }
  }

  // Update destination
  async updateDestination(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const organizationId = req.user.organizationId;
      const userId = req.user.id;

      // Validate request
      const validatedData = DestinationValidator.validateUpdateDestination(req.body);

      // Get existing destination
      const existingDestination = await this.destinationRepository.findById(id);
      if (!existingDestination) {
        const apiError = ApiErrorHandler.createNotFoundError('Destination', id);
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      // Check organization access
      if (existingDestination.organizationId !== organizationId) {
        const apiError = ApiErrorHandler.createForbiddenError();
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      // Prepare update data
      const updateData: any = {
        updatedBy: userId,
      };

      // Update fields if provided
      if (validatedData.name !== undefined) updateData.name = validatedData.name;
      if (validatedData.description !== undefined) updateData.description = validatedData.description;
      if (validatedData.enabled !== undefined) updateData.enabled = validatedData.enabled;
      if (validatedData.testMode !== undefined) updateData.testMode = validatedData.testMode;
      if (validatedData.requiredConsent !== undefined) updateData.requiredConsent = validatedData.requiredConsent;

      // Handle settings update
      if (validatedData.settings !== undefined) {
        updateData.settings = this.settingsEncryption.encrypt(validatedData.settings);
        updateData.settingsEncrypted = true;
      }

      // Update destination
      const updatedDestination = await this.destinationRepository.update(id, updateData);

      // Test connection if enabled
      if (updatedDestination.enabled) {
        await this.testDestinationConnection(updatedDestination.id);
      }

      // Trigger hot-reload for deployed instances
      await this.triggerHotReload(organizationId, updatedDestination.environment);

      this.logger.info('Destination updated', {
        destinationId: id,
        organizationId,
        changes: Object.keys(updateData),
      });

      // Decrypt settings for response
      const destinationWithDecryptedSettings = {
        ...updatedDestination,
        settings: updatedDestination.settingsEncrypted 
          ? this.settingsEncryption.decrypt(updatedDestination.settings as any)
          : updatedDestination.settings,
      };

      res.json(destinationWithDecryptedSettings);
    } catch (error) {
      if (error instanceof z.ZodError) {
        const apiError = ApiErrorHandler.createValidationError(error);
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      this.logger.error('Failed to update destination', {
        error: error.message,
        destinationId: req.params.id,
        organizationId: req.user.organizationId,
      });

      res.status(500).json({
        error: 'INTERNAL_ERROR',
        message: 'Failed to update destination',
        statusCode: 500,
      });
    }
  }

  // Delete destination
  async deleteDestination(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const organizationId = req.user.organizationId;

      // Get existing destination
      const existingDestination = await this.destinationRepository.findById(id);
      if (!existingDestination) {
        const apiError = ApiErrorHandler.createNotFoundError('Destination', id);
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      // Check organization access
      if (existingDestination.organizationId !== organizationId) {
        const apiError = ApiErrorHandler.createForbiddenError();
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      // Soft delete destination
      await this.destinationRepository.softDelete(id);

      // Trigger hot-reload for deployed instances
      await this.triggerHotReload(organizationId, existingDestination.environment);

      this.logger.info('Destination deleted', {
        destinationId: id,
        organizationId,
        environment: existingDestination.environment,
      });

      res.json({
        success: true,
        message: 'Destination deleted successfully',
      });
    } catch (error) {
      this.logger.error('Failed to delete destination', {
        error: error.message,
        destinationId: req.params.id,
        organizationId: req.user.organizationId,
      });

      res.status(500).json({
        error: 'INTERNAL_ERROR',
        message: 'Failed to delete destination',
        statusCode: 500,
      });
    }
  }

  // Test destination connection
  async testDestinationConnection(req: Request, res: Response): Promise<void> {
    try {
      const { id } = req.params;
      const organizationId = req.user.organizationId;

      // Get destination
      const destination = await this.destinationRepository.findById(id);
      if (!destination) {
        const apiError = ApiErrorHandler.createNotFoundError('Destination', id);
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      // Check organization access
      if (destination.organizationId !== organizationId) {
        const apiError = ApiErrorHandler.createForbiddenError();
        res.status(apiError.statusCode).json(apiError);
        return;
      }

      // Test connection
      const result = await this.testDestinationConnection(destination.id);

      res.json({
        success: result,
        message: result ? 'Connection successful' : 'Connection failed',
        testedAt: new Date().toISOString(),
        connectionStatus: result ? 'connected' : 'failed',
      });
    } catch (error) {
      this.logger.error('Failed to test destination connection', {
        error: error.message,
        destinationId: req.params.id,
        organizationId: req.user.organizationId,
      });

      res.status(500).json({
        error: 'INTERNAL_ERROR',
        message: 'Failed to test connection',
        statusCode: 500,
      });
    }
  }

  // Private helper methods
  private async testDestinationConnection(destinationId: string): Promise<boolean> {
    try {
      const destination = await this.destinationRepository.findById(destinationId);
      if (!destination) return false;

      // Decrypt settings
      const settings = destination.settingsEncrypted 
        ? this.settingsEncryption.decrypt(destination.settings as any)
        : destination.settings;

      // Create destination instance for testing
      const destinationInstance = await this.destinationManager.createDestinationInstance(
        destination.type,
        settings
      );

      // Test connection
      const isConnected = await destinationInstance.testConnection();

      // Update connection status
      await this.destinationRepository.update(destinationId, {
        lastTestedAt: new Date(),
        connectionStatus: isConnected ? 'connected' : 'failed',
        lastError: isConnected ? null : 'Connection test failed',
      });

      return isConnected;
    } catch (error) {
      this.logger.error('Destination connection test failed', {
        error: error.message,
        destinationId,
      });

      await this.destinationRepository.update(destinationId, {
        lastTestedAt: new Date(),
        connectionStatus: 'failed',
        lastError: error.message,
      });

      return false;
    }
  }

  private async triggerHotReload(organizationId: string, environment: string): Promise<void> {
    try {
      // This would trigger hot-reload for deployed instances
      // Implementation depends on your deployment system
      this.logger.info('Triggering hot-reload', {
        organizationId,
        environment,
      });

      // Example: Send webhook to deployed instances
      // await this.webhookService.sendHotReloadWebhook(organizationId, environment);
    } catch (error) {
      this.logger.error('Failed to trigger hot-reload', {
        error: error.message,
        organizationId,
        environment,
      });
    }
  }
}
```

### Self-Hosted Integration Note
```typescript
// For self-hosted users, they continue using direct configuration:
// These handlers are ONLY for consent.io control plane dashboard

// Self-hosted example:
const instance = await c15tInstance({
  analytics: {
    destinations: [
      posthog({ apiKey: 'phc_their_key' }),
      metaPixel({ pixelId: '123', accessToken: 'their_token' }),
    ],
  },
});

// Consent.io SaaS users manage destinations through these handlers + dashboard
```

## üß™ Testing Requirements
- Unit tests for all CRUD handlers
- Integration tests with database
- Encryption/decryption tests
- Hot-reload tests
- Error handling tests
- Authorization tests
- Connection testing tests

## üîç Definition of Done
- [ ] Create destination handler implemented
- [ ] List destinations handler implemented
- [ ] Get destination handler implemented
- [ ] Update destination handler implemented
- [ ] Delete destination handler implemented
- [ ] Test connection handler implemented
- [ ] Settings encryption/decryption added
- [ ] Hot-reload support added
- [ ] Unit tests for all handlers
- [ ] Code review completed

## üìö Related Documentation
- [Cloud Configuration](../docs/analytics-cloud-configuration.md)
- [Analytics Architecture Diagram](../docs/analytics-architecture-diagram.md)

## üîó Dependencies
- [3.1: Database Schema](./12-database-schema.md) ‚úÖ
- [3.2: Admin API Contracts](./13-admin-api-contracts.md) ‚úÖ

## üöÄ Next Ticket
[3.4: Add Database Loading Support](./15-database-loading.md)
