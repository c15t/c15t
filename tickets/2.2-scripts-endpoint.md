# Ticket 2.2: Scripts Endpoint

## üìã Ticket Details
**Phase**: 2 - Universal Destinations  
**Story Points**: 3  
**Priority**: High  
**Assignee**: TBD  
**Status**: Ready

## üîó Dependencies
**Depends on**: Ticket 2.1 (Universal Destination Interface)  
**Blocking**: Ticket 2.5 (Frontend Integration)  

## üéØ Description
Create endpoint to generate client-side scripts dynamically based on user consent and enabled destinations. This endpoint enables the frontend to load only the scripts that the user has consented to, ensuring GDPR compliance.

## üß† Context & Background
This endpoint is crucial for the universal destinations feature. It must:
- Generate scripts from universal destinations based on consent
- Filter scripts by user consent preferences
- Return scripts in a format the frontend can easily load
- Cache responses for performance
- Handle errors gracefully
- Support different script types (inline, external, module)

The endpoint integrates with:
- Universal destinations for script generation
- Consent management for filtering
- Caching layer for performance
- Frontend integration for script loading

## ‚úÖ Acceptance Criteria
- [ ] Create `GET /analytics/scripts` endpoint
- [ ] Accept consent preferences as query params
- [ ] Generate scripts from enabled destinations
- [ ] Return script definitions
- [ ] Add caching headers
- [ ] Add error handling
- [ ] Unit tests for endpoint

## üìÅ Files to Update
- `packages/backend/src/v2/handlers/analytics/` (add scripts handler)

## üîß Implementation Details

### Request/Response Types
```typescript
// Query parameters
interface ScriptsRequestQuery {
  consent: string; // JSON string of consent preferences
  organizationId?: string;
  environment?: string;
}

// Response structure
interface ScriptsResponse {
  scripts: Script[];
  metadata: {
    generatedAt: string;
    consent: AnalyticsConsent;
    destinationCount: number;
  };
}

// Script interface (from previous ticket)
interface Script {
  type: 'inline' | 'external' | 'module';
  content?: string;
  src?: string;
  async?: boolean;
  defer?: boolean;
  crossorigin?: 'anonymous' | 'use-credentials';
  integrity?: string;
  requiredConsent: ReadonlyArray<ConsentPurpose>;
  name: string;
  description?: string;
  version?: string;
}
```

### Handler Implementation
```typescript
import { Request, Response } from 'express';
import { z } from 'zod';
import { DestinationManager } from '../../analytics/destination-manager';
import { AnalyticsConsent, Script } from '../../analytics/types';
import { Logger } from '../../logger';

// Query validation schema
const ScriptsRequestQuerySchema = z.object({
  consent: z.string().min(1, 'Consent is required'),
  organizationId: z.string().optional(),
  environment: z.string().optional(),
});

// Consent validation schema
const ConsentSchema = z.object({
  necessary: z.boolean(),
  measurement: z.boolean(),
  marketing: z.boolean(),
  functionality: z.boolean(),
  experience: z.boolean(),
});

export async function getScriptsHandler(
  req: Request,
  res: Response,
  context: {
    destinationManager: DestinationManager;
    logger: Logger;
  }
): Promise<void> {
  const { destinationManager, logger } = context;
  
  try {
    // Validate query parameters
    const queryResult = ScriptsRequestQuerySchema.safeParse(req.query);
    if (!queryResult.success) {
      logger.warn('Invalid query parameters', { 
        errors: queryResult.error.errors,
        query: req.query 
      });
      
      res.status(400).json({
        error: 'Invalid query parameters',
        details: queryResult.error.errors,
      });
      return;
    }
    
    const { consent: consentString, organizationId, environment } = queryResult.data;
    
    // Parse and validate consent
    let consent: AnalyticsConsent;
    try {
      const parsedConsent = JSON.parse(consentString);
      const consentResult = ConsentSchema.safeParse(parsedConsent);
      
      if (!consentResult.success) {
        throw new Error('Invalid consent format');
      }
      
      consent = consentResult.data;
    } catch (error) {
      logger.warn('Invalid consent format', { consent: consentString });
      
      res.status(400).json({
        error: 'Invalid consent format',
        message: 'Consent must be a valid JSON object',
      });
      return;
    }
    
    // Generate scripts from destinations
    const scripts = await generateScriptsFromDestinations(
      destinationManager,
      consent,
      { organizationId, environment },
      logger
    );
    
    // Add caching headers
    const cacheMaxAge = 300; // 5 minutes
    res.set({
      'Cache-Control': `public, max-age=${cacheMaxAge}`,
      'ETag': generateETag(scripts, consent),
      'Content-Type': 'application/json',
    });
    
    // Return scripts
    const response: ScriptsResponse = {
      scripts,
      metadata: {
        generatedAt: new Date().toISOString(),
        consent,
        destinationCount: scripts.length,
      },
    };
    
    logger.info('Scripts generated successfully', {
      scriptCount: scripts.length,
      consent,
      organizationId,
      environment,
    });
    
    res.status(200).json(response);
    
  } catch (error) {
    logger.error('Failed to generate scripts', {
      error: error.message,
      stack: error.stack,
      query: req.query,
    });
    
    res.status(500).json({
      error: 'Internal server error',
      message: 'Failed to generate scripts',
    });
  }
}

// Generate scripts from all universal destinations
async function generateScriptsFromDestinations(
  destinationManager: DestinationManager,
  consent: AnalyticsConsent,
  options: { organizationId?: string; environment?: string },
  logger: Logger
): Promise<Script[]> {
  const scripts: Script[] = [];
  const loadedDestinations = destinationManager.getLoadedDestinations();
  
  for (const destination of loadedDestinations) {
    try {
      // Check if destination supports script generation
      if (!isUniversalDestination(destination.plugin)) {
        continue;
      }
      
      // Check if destination is enabled for this organization/environment
      if (!isDestinationEnabled(destination, options)) {
        continue;
      }
      
      // Generate scripts
      const generatedScripts = await destination.plugin.generateScript?.(
        destination.config.settings,
        consent
      );
      
      if (generatedScripts) {
        const scriptArray = Array.isArray(generatedScripts) ? generatedScripts : [generatedScripts];
        
        // Filter scripts by consent
        const filteredScripts = scriptArray.filter(script => 
          script.requiredConsent.every(purpose => consent[purpose])
        );
        
        scripts.push(...filteredScripts);
        
        logger.debug('Scripts generated for destination', {
          destination: destination.config.type,
          scriptCount: filteredScripts.length,
        });
      }
      
    } catch (error) {
      logger.error('Failed to generate scripts for destination', {
        destination: destination.config.type,
        error: error.message,
      });
      // Continue with other destinations
    }
  }
  
  // Sort scripts by dependencies
  return sortScriptsByDependencies(scripts);
}

// Check if destination is enabled for organization/environment
function isDestinationEnabled(
  destination: any,
  options: { organizationId?: string; environment?: string }
): boolean {
  // This would check against database configuration in Phase 3
  // For now, assume all loaded destinations are enabled
  return true;
}

// Sort scripts by dependencies
function sortScriptsByDependencies(scripts: Script[]): Script[] {
  const sorted: Script[] = [];
  const visited = new Set<string>();
  
  function visit(script: Script) {
    if (visited.has(script.name)) return;
    
    // Add dependencies first
    const dependencies = scripts.filter(s => 
      s.name !== script.name && 
      script.name.includes(s.name) // Simple dependency check
    );
    
    for (const dep of dependencies) {
      visit(dep);
    }
    
    visited.add(script.name);
    sorted.push(script);
  }
  
  for (const script of scripts) {
    visit(script);
  }
  
  return sorted;
}

// Generate ETag for caching
function generateETag(scripts: Script[], consent: AnalyticsConsent): string {
  const content = JSON.stringify({ scripts, consent });
  return `"${Buffer.from(content).toString('base64').slice(0, 16)}"`;
}

// Helper function to check if destination is universal
function isUniversalDestination(destination: any): boolean {
  return destination && 
         typeof destination.generateScript === 'function' &&
         destination.hasClientScript === true;
}
```

### Caching Strategy
```typescript
// Cache middleware for scripts endpoint
export function createScriptsCacheMiddleware() {
  const cache = new Map<string, { data: any; timestamp: number }>();
  const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  
  return (req: Request, res: Response, next: NextFunction) => {
    const cacheKey = `${req.query.consent}-${req.query.organizationId}-${req.query.environment}`;
    const cached = cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      res.set({
        'Cache-Control': 'public, max-age=300',
        'X-Cache': 'HIT',
      });
      res.json(cached.data);
      return;
    }
    
    // Store original json method
    const originalJson = res.json.bind(res);
    
    // Override json method to cache response
    res.json = function(data: any) {
      cache.set(cacheKey, { data, timestamp: Date.now() });
      res.set('X-Cache', 'MISS');
      return originalJson(data);
    };
    
    next();
  };
}
```

### Error Handling
```typescript
// Custom error types for scripts endpoint
export class ScriptsError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 400
  ) {
    super(message);
    this.name = 'ScriptsError';
  }
}

export class ConsentParseError extends ScriptsError {
  constructor(message: string) {
    super(message, 'CONSENT_PARSE_ERROR', 400);
  }
}

export class ScriptGenerationError extends ScriptsError {
  constructor(message: string, public destination?: string) {
    super(message, 'SCRIPT_GENERATION_ERROR', 500);
  }
}

// Error handling middleware
export function createScriptsErrorHandler(logger: Logger) {
  return (error: Error, req: Request, res: Response, next: NextFunction) => {
    if (error instanceof ScriptsError) {
      logger.warn('Scripts endpoint error', {
        code: error.code,
        message: error.message,
        destination: error.destination,
        query: req.query,
      });
      
      res.status(error.statusCode).json({
        error: error.code,
        message: error.message,
      });
      return;
    }
    
    logger.error('Unhandled error in scripts endpoint', {
      error: error.message,
      stack: error.stack,
      query: req.query,
    });
    
    res.status(500).json({
      error: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred',
    });
  };
}
```

### Frontend Integration Example
```typescript
// Example of how frontend would use this endpoint
async function loadAnalyticsScripts(consent: AnalyticsConsent): Promise<void> {
  try {
    const response = await fetch(`/analytics/scripts?consent=${encodeURIComponent(JSON.stringify(consent))}`);
    
    if (!response.ok) {
      throw new Error(`Failed to load scripts: ${response.status}`);
    }
    
    const { scripts } = await response.json();
    
    // Load each script
    for (const script of scripts) {
      await loadScript(script);
    }
    
  } catch (error) {
    console.error('Failed to load analytics scripts:', error);
  }
}

async function loadScript(script: Script): Promise<void> {
  switch (script.type) {
    case 'inline':
      if (script.content) {
        const scriptElement = document.createElement('script');
        scriptElement.textContent = script.content;
        document.head.appendChild(scriptElement);
      }
      break;
      
    case 'external':
      if (script.src) {
        const scriptElement = document.createElement('script');
        scriptElement.src = script.src;
        scriptElement.async = script.async || false;
        scriptElement.defer = script.defer || false;
        
        if (script.crossorigin) {
          scriptElement.crossOrigin = script.crossorigin;
        }
        
        if (script.integrity) {
          scriptElement.integrity = script.integrity;
        }
        
        document.head.appendChild(scriptElement);
      }
      break;
      
    case 'module':
      if (script.src) {
        const scriptElement = document.createElement('script');
        scriptElement.type = 'module';
        scriptElement.src = script.src;
        document.head.appendChild(scriptElement);
      }
      break;
  }
}
```

## üß™ Testing Requirements
- Unit tests for scripts endpoint
- Integration tests with real destinations
- Consent filtering tests
- Caching tests
- Error handling tests
- Script generation tests
- Dependency sorting tests

## üîç Definition of Done
- [ ] HTTP endpoint generates scripts based on consent
- [ ] Query parameters properly parsed
- [ ] Scripts generated from enabled destinations
- [ ] Proper HTTP responses returned
- [ ] Caching headers added
- [ ] Error handling implemented
- [ ] Unit tests for endpoint
- [ ] Code review completed

## üìö Related Documentation
- [Universal Destinations](../docs/analytics-universal-destinations.md)
- [Analytics Frontend Integration](../docs/analytics-frontend-integration.md)

## üîó Dependencies
- [2.1: Universal Destination Interface](./07-universal-destination-interface.md) ‚úÖ

## üöÄ Next Ticket
[2.3: Meta Pixel Universal Destination](./09-meta-pixel-universal.md)
