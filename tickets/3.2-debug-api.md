# Ticket 3.2: Debug API

## üìã Ticket Details
**Phase**: 3 - Advanced Features  
**Story Points**: 2  
**Priority**: Medium  
**Assignee**: TBD  
**Status**: Ready

## üîó Dependencies
**Depends on**: Ticket 3.1 (Event Queue & Offline Support)  
**Blocking**: None  

## üéØ Description
Implement a comprehensive debugging interface for the analytics system that provides real-time visibility into event processing, destination status, and queue operations. This enables developers to debug analytics issues and monitor system health.

## üß† Context & Background
The debug API provides essential debugging capabilities for the analytics system:
- **Event inspection** - View queued events, processing status, and errors
- **Destination monitoring** - Check destination health, connection status, and performance
- **Queue management** - Monitor queue size, retry counts, and processing metrics
- **Consent tracking** - Debug consent state changes and event filtering
- **Performance metrics** - Track processing times and throughput

The debug API must:
- Be available only in development mode
- Provide real-time data without affecting performance
- Include comprehensive logging and error details
- Support event replay for testing
- Enable queue manipulation for debugging

## ‚úÖ Acceptance Criteria
- [ ] Create `AnalyticsDebugAPI` interface
- [ ] Implement queue inspection methods
- [ ] Implement destination status monitoring
- [ ] Add event replay functionality
- [ ] Add performance metrics collection
- [ ] Add consent state debugging
- [ ] Unit tests for debug API
- [ ] Integration tests with analytics system

## üìÅ Files to Update
- `packages/backend/src/v2/handlers/analytics/` (add debug handler)

## üîß Implementation Details

### Debug API Implementation
```typescript
import { EventQueue } from './event-queue';
import { DestinationManager } from './destination-manager';
import { AnalyticsEvent, AnalyticsConsent, EventContext } from './types';

export interface AnalyticsDebugAPI {
  // Queue inspection
  getQueue(): QueuedEventInfo[];
  getQueueSize(): number;
  getQueueStats(): QueueStats;
  clearQueue(): Promise<void>;
  
  // Event inspection
  inspectEvent(eventId: string): EventDetails | null;
  getEventHistory(limit?: number): EventDetails[];
  replayEvent(eventId: string): Promise<void>;
  replayAll(): Promise<void>;
  
  // Destination monitoring
  getDestinations(): DestinationInfo[];
  getDestinationStatus(type: string): DestinationStatus | null;
  testDestination(type: string): Promise<boolean>;
  getDestinationMetrics(type: string): DestinationMetrics | null;
  
  // Consent debugging
  getConsentState(): AnalyticsConsent;
  getConsentHistory(): ConsentChange[];
  simulateConsentChange(consent: AnalyticsConsent): Promise<void>;
  
  // Performance metrics
  getPerformanceMetrics(): PerformanceMetrics;
  resetMetrics(): void;
  
  // System status
  getSystemStatus(): SystemStatus;
  exportDebugData(): DebugExport;
}

interface QueuedEventInfo {
  id: string;
  type: string;
  event: string;
  timestamp: number;
  retryCount: number;
  lastRetry?: number;
  consentAtTime: AnalyticsConsent;
  context: Partial<EventContext>;
}

interface QueueStats {
  size: number;
  oldestEvent?: number;
  newestEvent?: number;
  retryCounts: Record<number, number>;
  averageAge: number;
  processingRate: number;
}

interface EventDetails {
  id: string;
  event: AnalyticsEvent;
  context: EventContext;
  timestamp: number;
  processingHistory: ProcessingStep[];
  destinations: DestinationResult[];
  errors: ErrorInfo[];
}

interface ProcessingStep {
  step: string;
  timestamp: number;
  duration?: number;
  success: boolean;
  details?: any;
}

interface DestinationResult {
  type: string;
  success: boolean;
  duration: number;
  error?: string;
  retryCount: number;
}

interface ErrorInfo {
  message: string;
  stack?: string;
  timestamp: number;
  destination?: string;
  retryCount: number;
}

interface DestinationInfo {
  type: string;
  enabled: boolean;
  loaded: boolean;
  lastError?: string;
  lastTested?: number;
  connectionStatus: 'connected' | 'failed' | 'unknown' | 'testing';
  requiredConsent: string[];
  version: string;
}

interface DestinationStatus {
  type: string;
  loaded: boolean;
  lastError?: string;
  lastTested?: number;
  connectionStatus: string;
  metrics: DestinationMetrics;
}

interface DestinationMetrics {
  eventsProcessed: number;
  eventsSuccessful: number;
  eventsFailed: number;
  averageProcessingTime: number;
  lastProcessingTime?: number;
  errorRate: number;
  uptime: number;
}

interface ConsentChange {
  timestamp: number;
  oldConsent: AnalyticsConsent;
  newConsent: AnalyticsConsent;
  source: string;
  eventsAffected: number;
}

interface PerformanceMetrics {
  totalEventsProcessed: number;
  averageProcessingTime: number;
  peakProcessingTime: number;
  eventsPerSecond: number;
  errorRate: number;
  queueSize: number;
  destinationsLoaded: number;
  uptime: number;
}

interface SystemStatus {
  isOnline: boolean;
  consentState: AnalyticsConsent;
  queueSize: number;
  destinationsLoaded: number;
  lastActivity: number;
  errors: ErrorInfo[];
  performance: PerformanceMetrics;
}

interface DebugExport {
  timestamp: number;
  systemStatus: SystemStatus;
  queue: QueuedEventInfo[];
  destinations: DestinationInfo[];
  consentHistory: ConsentChange[];
  performanceMetrics: PerformanceMetrics;
  eventHistory: EventDetails[];
}

export class AnalyticsDebugAPI implements AnalyticsDebugAPI {
  private eventHistory: EventDetails[] = [];
  private consentHistory: ConsentChange[] = [];
  private performanceMetrics: PerformanceMetrics;
  private isEnabled: boolean;

  constructor(
    private eventQueue: EventQueue,
    private destinationManager: DestinationManager,
    private logger: Logger
  ) {
    this.isEnabled = process.env.NODE_ENV === 'development';
    this.performanceMetrics = this.initializeMetrics();
    
    if (this.isEnabled) {
      this.setupEventListeners();
    }
  }

  // Queue inspection methods
  getQueue(): QueuedEventInfo[] {
    if (!this.isEnabled) return [];
    
    const queueStats = this.eventQueue.getQueueStats();
    // Implementation would convert internal queue format to QueuedEventInfo
    return [];
  }

  getQueueSize(): number {
    if (!this.isEnabled) return 0;
    return this.eventQueue.getQueueStats().size;
  }

  getQueueStats(): QueueStats {
    if (!this.isEnabled) return this.getEmptyQueueStats();
    
    const stats = this.eventQueue.getQueueStats();
    return {
      size: stats.size,
      oldestEvent: stats.oldestEvent,
      newestEvent: stats.newestEvent,
      retryCounts: stats.retryCounts,
      averageAge: this.calculateAverageAge(stats),
      processingRate: this.calculateProcessingRate(),
    };
  }

  async clearQueue(): Promise<void> {
    if (!this.isEnabled) return;
    await this.eventQueue.clear();
    this.logger.info('Debug API: Queue cleared');
  }

  // Event inspection methods
  inspectEvent(eventId: string): EventDetails | null {
    if (!this.isEnabled) return null;
    
    return this.eventHistory.find(event => event.id === eventId) || null;
  }

  getEventHistory(limit: number = 100): EventDetails[] {
    if (!this.isEnabled) return [];
    
    return this.eventHistory
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, limit);
  }

  async replayEvent(eventId: string): Promise<void> {
    if (!this.isEnabled) return;
    
    const eventDetails = this.inspectEvent(eventId);
    if (!eventDetails) {
      throw new Error(`Event ${eventId} not found`);
    }

    this.logger.info('Debug API: Replaying event', { eventId });
    
    try {
      // Re-queue the event for processing
      await this.eventQueue.queueEvent(eventDetails.event, eventDetails.context);
    } catch (error) {
      this.logger.error('Debug API: Failed to replay event', { eventId, error });
      throw error;
    }
  }

  async replayAll(): Promise<void> {
    if (!this.isEnabled) return;
    
    const recentEvents = this.getEventHistory(50);
    this.logger.info('Debug API: Replaying all events', { count: recentEvents.length });

    for (const eventDetails of recentEvents) {
      try {
        await this.eventQueue.queueEvent(eventDetails.event, eventDetails.context);
      } catch (error) {
        this.logger.error('Debug API: Failed to replay event', { 
          eventId: eventDetails.id, 
          error 
        });
      }
    }
  }

  // Destination monitoring methods
  getDestinations(): DestinationInfo[] {
    if (!this.isEnabled) return [];
    
    const loadedDestinations = this.destinationManager.getLoadedDestinations();
    
    return loadedDestinations.map(dest => ({
      type: dest.config.type,
      enabled: dest.config.enabled,
      loaded: dest.loaded,
      lastError: dest.lastError?.message,
      lastTested: dest.lastTested?.getTime(),
      connectionStatus: dest.connectionStatus || 'unknown',
      requiredConsent: dest.config.requiredConsent,
      version: dest.plugin.version,
    }));
  }

  getDestinationStatus(type: string): DestinationStatus | null {
    if (!this.isEnabled) return null;
    
    const instance = this.destinationManager.getDestinationStatus(type);
    if (!instance) return null;

    return {
      type: instance.config.type,
      loaded: instance.loaded,
      lastError: instance.lastError?.message,
      lastTested: instance.lastTested?.getTime(),
      connectionStatus: instance.connectionStatus || 'unknown',
      metrics: this.getDestinationMetrics(type),
    };
  }

  async testDestination(type: string): Promise<boolean> {
    if (!this.isEnabled) return false;
    
    try {
      return await this.destinationManager.testDestination(type);
    } catch (error) {
      this.logger.error('Debug API: Destination test failed', { type, error });
      return false;
    }
  }

  getDestinationMetrics(type: string): DestinationMetrics | null {
    if (!this.isEnabled) return null;
    
    // Implementation would track metrics per destination
    return {
      eventsProcessed: 0,
      eventsSuccessful: 0,
      eventsFailed: 0,
      averageProcessingTime: 0,
      lastProcessingTime: undefined,
      errorRate: 0,
      uptime: 0,
    };
  }

  // Consent debugging methods
  getConsentState(): AnalyticsConsent {
    if (!this.isEnabled) return this.getDefaultConsent();
    
    // Implementation would get current consent state
    return this.getDefaultConsent();
  }

  getConsentHistory(): ConsentChange[] {
    if (!this.isEnabled) return [];
    return [...this.consentHistory];
  }

  async simulateConsentChange(consent: AnalyticsConsent): Promise<void> {
    if (!this.isEnabled) return;
    
    const oldConsent = this.getConsentState();
    const change: ConsentChange = {
      timestamp: Date.now(),
      oldConsent,
      newConsent: consent,
      source: 'debug-api',
      eventsAffected: 0, // Would calculate based on queue
    };

    this.consentHistory.push(change);
    
    // Trigger consent update
    await this.eventQueue.updateConsent(consent);
    
    this.logger.info('Debug API: Simulated consent change', { change });
  }

  // Performance metrics methods
  getPerformanceMetrics(): PerformanceMetrics {
    if (!this.isEnabled) return this.getEmptyPerformanceMetrics();
    return { ...this.performanceMetrics };
  }

  resetMetrics(): void {
    if (!this.isEnabled) return;
    
    this.performanceMetrics = this.initializeMetrics();
    this.eventHistory = [];
    this.consentHistory = [];
    
    this.logger.info('Debug API: Metrics reset');
  }

  // System status methods
  getSystemStatus(): SystemStatus {
    if (!this.isEnabled) return this.getEmptySystemStatus();
    
    return {
      isOnline: navigator.onLine,
      consentState: this.getConsentState(),
      queueSize: this.getQueueSize(),
      destinationsLoaded: this.getDestinations().length,
      lastActivity: Date.now(),
      errors: this.getRecentErrors(),
      performance: this.getPerformanceMetrics(),
    };
  }

  exportDebugData(): DebugExport {
    if (!this.isEnabled) return this.getEmptyDebugExport();
    
    return {
      timestamp: Date.now(),
      systemStatus: this.getSystemStatus(),
      queue: this.getQueue(),
      destinations: this.getDestinations(),
      consentHistory: this.getConsentHistory(),
      performanceMetrics: this.getPerformanceMetrics(),
      eventHistory: this.getEventHistory(1000),
    };
  }

  // Private helper methods
  private setupEventListeners(): void {
    // Listen for events being processed
    // Listen for consent changes
    // Listen for destination status changes
    // Update metrics accordingly
  }

  private initializeMetrics(): PerformanceMetrics {
    return {
      totalEventsProcessed: 0,
      averageProcessingTime: 0,
      peakProcessingTime: 0,
      eventsPerSecond: 0,
      errorRate: 0,
      queueSize: 0,
      destinationsLoaded: 0,
      uptime: Date.now(),
    };
  }

  private calculateAverageAge(stats: any): number {
    if (!stats.oldestEvent || !stats.newestEvent) return 0;
    return (stats.newestEvent - stats.oldestEvent) / 2;
  }

  private calculateProcessingRate(): number {
    // Implementation would calculate events per second
    return 0;
  }

  private getRecentErrors(): ErrorInfo[] {
    // Implementation would return recent errors
    return [];
  }

  private getDefaultConsent(): AnalyticsConsent {
    return {
      necessary: true,
      measurement: false,
      marketing: false,
      functionality: false,
      experience: false,
    };
  }

  private getEmptyQueueStats(): QueueStats {
    return {
      size: 0,
      retryCounts: {},
      averageAge: 0,
      processingRate: 0,
    };
  }

  private getEmptyPerformanceMetrics(): PerformanceMetrics {
    return {
      totalEventsProcessed: 0,
      averageProcessingTime: 0,
      peakProcessingTime: 0,
      eventsPerSecond: 0,
      errorRate: 0,
      queueSize: 0,
      destinationsLoaded: 0,
      uptime: 0,
    };
  }

  private getEmptySystemStatus(): SystemStatus {
    return {
      isOnline: true,
      consentState: this.getDefaultConsent(),
      queueSize: 0,
      destinationsLoaded: 0,
      lastActivity: Date.now(),
      errors: [],
      performance: this.getEmptyPerformanceMetrics(),
    };
  }

  private getEmptyDebugExport(): DebugExport {
    return {
      timestamp: Date.now(),
      systemStatus: this.getEmptySystemStatus(),
      queue: [],
      destinations: [],
      consentHistory: [],
      performanceMetrics: this.getEmptyPerformanceMetrics(),
      eventHistory: [],
    };
  }
}
```

### Performance Metrics Collector
```typescript
export class PerformanceMetricsCollector {
  private metrics: Map<string, number[]> = new Map();
  private timers: Map<string, number> = new Map();

  startTimer(key: string): void {
    this.timers.set(key, Date.now());
  }

  endTimer(key: string): number {
    const startTime = this.timers.get(key);
    if (!startTime) return 0;

    const duration = Date.now() - startTime;
    this.timers.delete(key);

    // Store the duration
    if (!this.metrics.has(key)) {
      this.metrics.set(key, []);
    }
    this.metrics.get(key)!.push(duration);

    return duration;
  }

  getAverageTime(key: string): number {
    const times = this.metrics.get(key);
    if (!times || times.length === 0) return 0;
    
    return times.reduce((sum, time) => sum + time, 0) / times.length;
  }

  getPeakTime(key: string): number {
    const times = this.metrics.get(key);
    if (!times || times.length === 0) return 0;
    
    return Math.max(...times);
  }

  getCount(key: string): number {
    return this.metrics.get(key)?.length || 0;
  }

  reset(): void {
    this.metrics.clear();
    this.timers.clear();
  }
}
```

### Usage Examples
```typescript
// Initialize debug API
const debugAPI = new AnalyticsDebugAPI(eventQueue, destinationManager, logger);

// In development mode only
if (process.env.NODE_ENV === 'development') {
  // Expose debug API globally
  (window as any).analyticsDebug = debugAPI;
  
  // Console commands for debugging
  console.log('Analytics Debug Commands:');
  console.log('analyticsDebug.getQueue() - View queued events');
  console.log('analyticsDebug.getDestinations() - View destination status');
  console.log('analyticsDebug.getSystemStatus() - View system health');
  console.log('analyticsDebug.replayEvent(eventId) - Replay specific event');
  console.log('analyticsDebug.exportDebugData() - Export all debug data');
}

// Example usage in browser console
// analyticsDebug.getQueue()
// analyticsDebug.getQueueStats()
// analyticsDebug.getDestinations()
// analyticsDebug.testDestination('posthog')
// analyticsDebug.simulateConsentChange({ necessary: true, measurement: true })
// analyticsDebug.replayAll()
// analyticsDebug.exportDebugData()
```

## üß™ Testing Requirements
- Unit tests for debug API methods
- Unit tests for performance metrics collection
- Unit tests for event replay functionality
- Unit tests for consent simulation
- Integration tests with analytics system
- Performance tests for debug overhead

## üîç Definition of Done
- [ ] AnalyticsDebugAPI interface implemented
- [ ] Queue inspection methods working
- [ ] Destination status monitoring implemented
- [ ] Event replay functionality working
- [ ] Performance metrics collection implemented
- [ ] Consent state debugging implemented
- [ ] Unit tests for debug API
- [ ] Integration tests with analytics system
- [ ] Code review completed

## üìö Related Documentation
- [Analytics Architecture Diagram](../docs/analytics-architecture-diagram.md)
- [Analytics Frontend Integration](../docs/analytics-frontend-integration.md)

## üîó Dependencies
- [5.1: Event Queue & Offline Support](./22-event-queue-offline-support.md) ‚úÖ

## üöÄ Next Ticket
[5.3: Implement Lazy Loading](./24-lazy-loading.md)
