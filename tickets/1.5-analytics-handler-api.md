# Ticket 1.5: Analytics Handler & API

## üìã Ticket Details
**Phase**: 1 - Core Analytics Infrastructure  
**Story Points**: 3  
**Priority**: Critical  
**Assignee**: TBD  
**Status**: Ready

## üîó Dependencies
**Depends on**: Ticket 1.1 (Core Analytics Types), Ticket 1.2 (Destination Registry & Manager), Ticket 1.3 (Event Processor)  
**Blocking**: Ticket 1.6 (c15tInstance Factory)  

## üéØ Description
Build the HTTP handler for analytics events that serves as the main entry point for all analytics data. This handler receives events from frontend applications and processes them through the analytics pipeline.

## üß† Context & Background
This handler is the public API that frontend applications will call to send analytics events. It must:
- Accept events from multiple sources (web, mobile, server)
- Validate incoming data thoroughly
- Process events through the analytics pipeline
- Handle errors gracefully without breaking the user experience
- Provide proper HTTP responses and status codes
- Include rate limiting to prevent abuse
- Log requests for debugging and monitoring

The handler integrates with:
- EventProcessor for event validation and enrichment
- DestinationManager for routing events to destinations
- Existing consent system for GDPR compliance
- Rate limiting middleware for protection

## ‚úÖ Acceptance Criteria
- [ ] Create `POST /analytics/process` endpoint
- [ ] Validate request body (events array + consent)
- [ ] Process events through EventProcessor
- [ ] Return success/error responses
- [ ] Add request logging
- [ ] Add rate limiting
- [ ] Unit tests for handler
- [ ] Integration tests with real requests

## üìÅ Files to Update
- `packages/backend/src/v2/handlers/analytics/` (extend existing handlers)

## üîß Implementation Details

### Request/Response Types
```typescript
// Request body structure
interface ProcessEventsRequest {
  events: AnalyticsEvent[];
  consent: AnalyticsConsent;
  sessionId?: string;
  userId?: string;
  anonymousId?: string;
  context?: {
    userAgent?: string;
    ip?: string;
    referrer?: string;
    custom?: Record<string, unknown>;
  };
}

// Response structure
interface ProcessEventsResponse {
  success: boolean;
  processedCount: number;
  errors?: Array<{
    eventId: string;
    error: string;
  }>;
  message?: string;
}
```

### Handler Implementation
```typescript
import { Request, Response } from 'express';
import { z } from 'zod';
import { EventProcessor } from '../../analytics/event-processor';
import { DestinationManager } from '../../analytics/destination-manager';
import { AnalyticsEvent, AnalyticsConsent, EventContext } from '../../analytics/types';

// Request validation schema
const ProcessEventsRequestSchema = z.object({
  events: z.array(z.object({
    type: z.enum(['track', 'page', 'identify', 'group', 'alias', 'consent']),
    timestamp: z.string().datetime().optional(),
    eventId: z.string().optional(),
    sessionId: z.string().optional(),
    userId: z.string().optional(),
    // Event-specific fields
    event: z.string().optional(),
    name: z.string().optional(),
    properties: z.record(z.unknown()).optional(),
    traits: z.record(z.unknown()).optional(),
    groupId: z.string().optional(),
    previousId: z.string().optional(),
    action: z.enum(['granted', 'revoked', 'updated']).optional(),
    preferences: z.record(z.boolean()).optional(),
    source: z.enum(['banner', 'api', 'admin']).optional(),
  })),
  consent: z.object({
    necessary: z.boolean(),
    measurement: z.boolean(),
    marketing: z.boolean(),
    functionality: z.boolean(),
    experience: z.boolean(),
  }),
  sessionId: z.string().optional(),
  userId: z.string().optional(),
  anonymousId: z.string().optional(),
  context: z.object({
    userAgent: z.string().optional(),
    ip: z.string().optional(),
    referrer: z.string().optional(),
    custom: z.record(z.unknown()).optional(),
  }).optional(),
});

export async function processEventsHandler(
  req: Request,
  res: Response,
  context: {
    eventProcessor: EventProcessor;
    destinationManager: DestinationManager;
    logger: Logger;
  }
): Promise<void> {
  const { eventProcessor, destinationManager, logger } = context;
  
  try {
    // Validate request body
    const validationResult = ProcessEventsRequestSchema.safeParse(req.body);
    if (!validationResult.success) {
      logger.warn('Invalid request body', { 
        errors: validationResult.error.errors,
        body: req.body 
      });
      
      res.status(400).json({
        success: false,
        error: 'Invalid request body',
        details: validationResult.error.errors,
      });
      return;
    }
    
    const { events, consent, sessionId, userId, anonymousId, context: requestContext } = validationResult.data;
    
    // Generate session ID if not provided
    const finalSessionId = sessionId || generateSessionId();
    
    // Create event context
    const eventContext: EventContext = {
      sessionId: finalSessionId,
      sessionStart: new Date(),
      userId,
      anonymousId,
      consent,
      userAgent: requestContext?.userAgent || req.headers['user-agent'],
      ip: requestContext?.ip || req.ip,
      referrer: requestContext?.referrer || req.headers.referer,
      custom: requestContext?.custom,
    };
    
    // Process events through pipeline
    const processedEvents = await eventProcessor.processEvents(events, eventContext);
    
    // Route to destinations
    await destinationManager.processEvents(processedEvents, eventContext);
    
    // Handle consent events specially
    const consentEvents = events.filter(e => e.type === 'consent');
    if (consentEvents.length > 0) {
      await handleConsentEvents(consentEvents, eventContext);
    }
    
    // Log successful processing
    logger.info('Events processed successfully', {
      eventCount: events.length,
      sessionId: finalSessionId,
      userId,
    });
    
    // Return success response
    res.status(200).json({
      success: true,
      processedCount: events.length,
      message: 'Events processed successfully',
    });
    
  } catch (error) {
    logger.error('Failed to process events', {
      error: error.message,
      stack: error.stack,
      body: req.body,
    });
    
    res.status(500).json({
      success: false,
      error: 'Internal server error',
      message: 'Failed to process events',
    });
  }
}

// Helper function to handle consent events
async function handleConsentEvents(
  consentEvents: AnalyticsEvent[],
  context: EventContext
): Promise<void> {
  // Call existing consent management system
  for (const event of consentEvents) {
    if (event.type === 'consent') {
      // Update consent in database
      await updateConsentInDatabase({
        sessionId: context.sessionId,
        userId: context.userId,
        preferences: event.preferences,
        action: event.action,
        source: event.source,
        timestamp: new Date(),
      });
    }
  }
}

// Rate limiting middleware
export function createRateLimitMiddleware() {
  const requests = new Map<string, { count: number; resetTime: number }>();
  
  return (req: Request, res: Response, next: NextFunction) => {
    const key = req.ip || 'unknown';
    const now = Date.now();
    const windowMs = 60 * 1000; // 1 minute
    const maxRequests = 100; // 100 requests per minute
    
    const current = requests.get(key);
    
    if (!current || now > current.resetTime) {
      requests.set(key, { count: 1, resetTime: now + windowMs });
      next();
      return;
    }
    
    if (current.count >= maxRequests) {
      res.status(429).json({
        success: false,
        error: 'Rate limit exceeded',
        message: 'Too many requests',
      });
      return;
    }
    
    current.count++;
    next();
  };
}

// Request logging middleware
export function createRequestLoggingMiddleware(logger: Logger) {
  return (req: Request, res: Response, next: NextFunction) => {
    const start = Date.now();
    
    res.on('finish', () => {
      const duration = Date.now() - start;
      
      logger.info('Analytics request processed', {
        method: req.method,
        url: req.url,
        statusCode: res.statusCode,
        duration,
        userAgent: req.headers['user-agent'],
        ip: req.ip,
      });
    });
    
    next();
  };
}
```

### Error Handling
```typescript
// Custom error types
export class AnalyticsError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 400
  ) {
    super(message);
    this.name = 'AnalyticsError';
  }
}

export class ValidationError extends AnalyticsError {
  constructor(message: string, public field?: string) {
    super(message, 'VALIDATION_ERROR', 400);
  }
}

export class RateLimitError extends AnalyticsError {
  constructor() {
    super('Rate limit exceeded', 'RATE_LIMIT_EXCEEDED', 429);
  }
}

// Error handling middleware
export function createErrorHandler(logger: Logger) {
  return (error: Error, req: Request, res: Response, next: NextFunction) => {
    if (error instanceof AnalyticsError) {
      res.status(error.statusCode).json({
        success: false,
        error: error.code,
        message: error.message,
      });
      return;
    }
    
    logger.error('Unhandled error in analytics handler', {
      error: error.message,
      stack: error.stack,
      url: req.url,
      method: req.method,
    });
    
    res.status(500).json({
      success: false,
      error: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred',
    });
  };
}
```

## üß™ Testing Requirements
- Unit tests for HTTP handler
- Integration tests with real requests
- Validation tests for request body
- Error handling tests
- Rate limiting tests
- Request logging tests
- Consent event handling tests

## üîç Definition of Done
- [ ] HTTP endpoint accepts events and consent
- [ ] Request validation implemented
- [ ] Events processed through pipeline
- [ ] Proper HTTP responses returned
- [ ] Request logging added
- [ ] Rate limiting implemented
- [ ] Unit tests for handler
- [ ] Integration tests with real requests
- [ ] Code review completed

## üìö Related Documentation
- [Analytics Architecture Diagram](../docs/analytics-architecture-diagram.md)
- [Analytics Frontend Integration](../docs/analytics-frontend-integration.md)

## üîó Dependencies
- [1.1: Core Analytics Types](./01-core-analytics-types.md) ‚úÖ
- [1.2: Destination Registry & Manager](./02-destination-registry-manager.md) ‚úÖ
- [1.3: Event Processor](./03-event-processor.md) ‚úÖ
- [1.4: Core Server Destinations](./04-core-server-destinations.md) ‚úÖ

## üöÄ Next Ticket
[1.6: Create c15tInstance Factory](./06-c15t-instance-factory.md)
