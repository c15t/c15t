# Ticket 1.5: Analytics Handler & API

## üìã Ticket Details
**Phase**: 1 - Core Analytics Infrastructure  
**Story Points**: 3  
**Priority**: Critical  
**Assignee**: TBD  
**Status**: Ready

## üîó Dependencies
**Depends on**: Ticket 1.1 (Core Analytics Types), Ticket 1.2 (Destination Registry & Manager), Ticket 1.3 (Event Processor)  
**Blocking**: Ticket 1.6 (c15tInstance Factory)  

## üéØ Description
Build the HTTP handler for analytics events that serves as the main entry point for all analytics data. This handler receives events from frontend applications and processes them through the analytics pipeline.

## üß† Context & Background
This handler is the public API that frontend applications will call to send analytics events. It must:
- Accept events from multiple sources (web, mobile, server)
- Validate incoming data thoroughly
- Process events through the analytics pipeline
- Handle errors gracefully without breaking the user experience
- Provide proper HTTP responses and status codes
- Include rate limiting to prevent abuse
- Log requests for debugging and monitoring

The handler integrates with:
- EventProcessor for event validation and enrichment
- DestinationManager for routing events to destinations
- Existing consent system for GDPR compliance
- Rate limiting middleware for protection

## ‚úÖ Acceptance Criteria
- [ ] Create `POST /analytics/process` ORPC v2 procedure
- [ ] Validate request body using Zod schemas
- [ ] Process events through EventProcessor
- [ ] Return typed success/error responses
- [ ] Add request logging middleware
- [ ] Add rate limiting middleware
- [ ] Unit tests for procedure handler
- [ ] Integration tests with ORPC client

## üìÅ Files to Update
- `packages/backend/src/v2/handlers/analytics/` (extend existing handlers)

## üîß Implementation Details

### ORPC v2 Handler Implementation
```typescript
import { z } from 'zod';
import { EventProcessor } from '../../analytics/event-processor';
import { DestinationManager } from '../../analytics/destination-manager';
import { AnalyticsEvent, AnalyticsConsent, EventContext } from '../../analytics/types';
import type { Logger } from '@doubletie/logger';

// Request validation schema
const ProcessEventsRequestSchema = z.object({
  events: z.array(z.object({
    type: z.enum(['track', 'page', 'identify', 'group', 'alias', 'consent']),
    timestamp: z.string().datetime().optional(),
    eventId: z.string().optional(),
    sessionId: z.string().optional(),
    userId: z.string().optional(),
    // Event-specific fields
    event: z.string().optional(),
    name: z.string().optional(),
    properties: z.record(z.unknown()).optional(),
    traits: z.record(z.unknown()).optional(),
    groupId: z.string().optional(),
    previousId: z.string().optional(),
    action: z.enum(['granted', 'revoked', 'updated']).optional(),
    preferences: z.record(z.boolean()).optional(),
    source: z.enum(['banner', 'api', 'admin']).optional(),
  })),
  consent: z.object({
    necessary: z.boolean(),
    measurement: z.boolean(),
    marketing: z.boolean(),
    functionality: z.boolean(),
    experience: z.boolean(),
  }),
  sessionId: z.string().optional(),
  userId: z.string().optional(),
  anonymousId: z.string().optional(),
  context: z.object({
    userAgent: z.string().optional(),
    ip: z.string().optional(),
    referrer: z.string().optional(),
    custom: z.record(z.unknown()).optional(),
  }).optional(),
});

// Response schema
const ProcessEventsResponseSchema = z.object({
  success: z.boolean(),
  processedCount: z.number(),
  errors: z.array(z.object({
    eventId: z.string(),
    error: z.string(),
  })).optional(),
  message: z.string().optional(),
});

// ORPC v2 procedure definition
export const processEventsProcedure = {
  method: 'POST',
  path: '/analytics/process',
  input: ProcessEventsRequestSchema,
  output: ProcessEventsResponseSchema,
  handler: async (
    input: z.infer<typeof ProcessEventsRequestSchema>,
    context: {
      eventProcessor: EventProcessor;
      destinationManager: DestinationManager;
      logger: Logger;
      request: {
        headers: Record<string, string>;
        ip?: string;
      };
    }
  ): Promise<z.infer<typeof ProcessEventsResponseSchema>> => {
    const { eventProcessor, destinationManager, logger, request } = context;
    
    try {
      const { events, consent, sessionId, userId, anonymousId, context: requestContext } = input;
      
      // Generate session ID if not provided
      const finalSessionId = sessionId || generateSessionId();
      
      // Create event context
      const eventContext: EventContext = {
        sessionId: finalSessionId,
        sessionStart: new Date(),
        userId,
        anonymousId,
        consent,
        userAgent: requestContext?.userAgent || request.headers['user-agent'],
        ip: requestContext?.ip || request.ip,
        referrer: requestContext?.referrer || request.headers.referer,
        custom: requestContext?.custom,
      };
      
      // Process events through pipeline
      const processedEvents = await eventProcessor.processEvents(events, eventContext);
      
      // Route to destinations
      await destinationManager.processEvents(processedEvents, eventContext);
      
      // Handle consent events specially
      const consentEvents = events.filter(e => e.type === 'consent');
      if (consentEvents.length > 0) {
        await handleConsentEvents(consentEvents, eventContext);
      }
      
      // Log successful processing
      logger.info('Events processed successfully', {
        eventCount: events.length,
        sessionId: finalSessionId,
        userId,
      });
      
      // Return success response
      return {
        success: true,
        processedCount: events.length,
        message: 'Events processed successfully',
      };
      
    } catch (error) {
      logger.error('Failed to process events', {
        error: error.message,
        stack: error.stack,
        input,
      });
      
      throw new Error('Failed to process events');
    }
  },
};

// Helper function to handle consent events
async function handleConsentEvents(
  consentEvents: AnalyticsEvent[],
  context: EventContext
): Promise<void> {
  // Call existing consent management system
  for (const event of consentEvents) {
    if (event.type === 'consent') {
      // Update consent in database
      await updateConsentInDatabase({
        sessionId: context.sessionId,
        userId: context.userId,
        preferences: event.preferences,
        action: event.action,
        source: event.source,
        timestamp: new Date(),
      });
    }
  }
}

// ORPC v2 middleware for rate limiting
export function createRateLimitMiddleware() {
  const requests = new Map<string, { count: number; resetTime: number }>();
  
  return {
    name: 'rateLimit',
    handler: async (input: unknown, context: { request: { ip?: string } }) => {
      const key = context.request.ip || 'unknown';
      const now = Date.now();
      const windowMs = 60 * 1000; // 1 minute
      const maxRequests = 100; // 100 requests per minute
      
      const current = requests.get(key);
      
      if (!current || now > current.resetTime) {
        requests.set(key, { count: 1, resetTime: now + windowMs });
        return input;
      }
      
      if (current.count >= maxRequests) {
        throw new RateLimitError();
      }
      
      current.count++;
      return input;
    },
  };
}

// ORPC v2 middleware for request logging
export function createRequestLoggingMiddleware(logger: Logger) {
  return {
    name: 'requestLogging',
    handler: async (input: unknown, context: { request: { headers: Record<string, string>; ip?: string } }) => {
      const start = Date.now();
      
      // Log after processing (this would be handled by ORPC's response middleware)
      logger.info('Analytics request processed', {
        method: 'POST',
        path: '/analytics/process',
        duration: Date.now() - start,
        userAgent: context.request.headers['user-agent'],
        ip: context.request.ip,
      });
      
      return input;
    },
  };
}
```

### Error Handling
```typescript
// Custom error types for ORPC v2
export class AnalyticsError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 400
  ) {
    super(message);
    this.name = 'AnalyticsError';
  }
}

export class ValidationError extends AnalyticsError {
  constructor(message: string, public field?: string) {
    super(message, 'VALIDATION_ERROR', 400);
  }
}

export class RateLimitError extends AnalyticsError {
  constructor() {
    super('Rate limit exceeded', 'RATE_LIMIT_EXCEEDED', 429);
  }
}

// ORPC v2 error handler middleware
export function createErrorHandlerMiddleware(logger: Logger) {
  return {
    name: 'errorHandler',
    handler: async (input: unknown, context: any, next: () => Promise<unknown>) => {
      try {
        return await next();
      } catch (error) {
        if (error instanceof AnalyticsError) {
          // ORPC will handle the error response based on the error type
          throw error;
        }
        
        logger.error('Unhandled error in analytics handler', {
          error: error.message,
          stack: error.stack,
          input,
        });
        
        throw new AnalyticsError('An unexpected error occurred', 'INTERNAL_ERROR', 500);
      }
    },
  };
}
```

## üß™ Testing Requirements
- Unit tests for ORPC v2 procedure handler
- Integration tests with ORPC client
- Validation tests for request schemas
- Error handling tests
- Rate limiting tests
- Request logging tests
- Consent event handling tests

## üîç Definition of Done
- [ ] ORPC v2 procedure accepts events and consent
- [ ] Request validation implemented with Zod schemas
- [ ] Events processed through pipeline
- [ ] Proper typed responses returned
- [ ] Request logging middleware added
- [ ] Rate limiting middleware implemented
- [ ] Unit tests for procedure handler
- [ ] Integration tests with ORPC client
- [ ] Code review completed

## üìö Related Documentation
- [Analytics Architecture Diagram](../docs/analytics-architecture-diagram.md)
- [Analytics Frontend Integration](../docs/analytics-frontend-integration.md)

## üîó Dependencies
- [1.1: Core Analytics Types](./01-core-analytics-types.md) ‚úÖ
- [1.2: Destination Registry & Manager](./02-destination-registry-manager.md) ‚úÖ
- [1.3: Event Processor](./03-event-processor.md) ‚úÖ
- [1.4: Core Server Destinations](./04-core-server-destinations.md) ‚úÖ

## üöÄ Next Ticket
[1.6: Create c15tInstance Factory](./06-c15t-instance-factory.md)
