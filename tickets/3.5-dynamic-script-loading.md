# Ticket 3.5: Dynamic Script Loading Hook

## 📋 Ticket Details
**Phase**: 3 - Advanced Features  
**Story Points**: 3  
**Priority**: High  
**Assignee**: TBD  
**Status**: Ready

## 🔗 Dependencies
**Depends on**: Phase 2 Complete  
**Blocking**: None  

## 🎯 Description
Implement the `useScriptManager` hook for dynamic script loading and unloading based on consent changes. This hook manages client-side analytics scripts, handles consent-aware loading, and provides real-time script management capabilities.

## 🧠 Context & Background
The dynamic script loading hook is essential for GDPR-compliant analytics:
- **Consent-aware loading** - Only loads scripts user has consented to
- **Dynamic loading/unloading** - Scripts are loaded/unloaded as consent changes
- **Script deduplication** - Prevents loading the same script multiple times
- **Error handling** - Gracefully handles script loading failures
- **Performance optimization** - Lazy loads scripts only when needed
- **Cross-tab synchronization** - Syncs script state across browser tabs

The hook must:
- Load scripts dynamically from the `/analytics/scripts` endpoint
- Handle consent changes and update scripts accordingly
- Provide loading status and error information
- Support script preloading and caching
- Handle script cleanup and memory management
- Work with universal destinations

## ✅ Acceptance Criteria
- [ ] Create `useScriptManager` hook
- [ ] Implement dynamic script loading/unloading
- [ ] Add consent-aware script management
- [ ] Add script deduplication
- [ ] Add error handling for script failures
- [ ] Add cross-tab synchronization
- [ ] Unit tests for script management
- [ ] Integration tests with consent system

## 📁 Files to Update
- `packages/core/src/libs/script-loader/` (extend existing script loader)

## 🔧 Implementation Details

### Script Manager Hook Implementation
```typescript
import { useState, useEffect, useCallback, useRef } from 'react';
import { AnalyticsConsent } from 'c15t';
import { ScriptLoader } from '../utils/script-loader';
import { ScriptCache } from '../utils/script-cache';

export interface ScriptManagerOptions {
  endpoint?: string;
  enablePreloading?: boolean;
  enableCaching?: boolean;
  enableCrossTabSync?: boolean;
  retryAttempts?: number;
  retryDelayMs?: number;
  onScriptLoad?: (script: LoadedScript) => void;
  onScriptError?: (error: ScriptError) => void;
  onConsentChange?: (consent: AnalyticsConsent) => void;
}

export interface LoadedScript {
  id: string;
  type: string;
  src: string;
  loaded: boolean;
  error?: string;
  loadTime: number;
  consent: AnalyticsConsent;
}

export interface ScriptError {
  scriptId: string;
  error: Error;
  retryCount: number;
  timestamp: number;
}

export interface ScriptManagerState {
  scripts: Map<string, LoadedScript>;
  loading: boolean;
  error?: string;
  consent: AnalyticsConsent;
  stats: ScriptManagerStats;
}

export interface ScriptManagerStats {
  totalScripts: number;
  loadedScripts: number;
  failedScripts: number;
  averageLoadTime: number;
  lastUpdate: number;
}

export interface ScriptManagerActions {
  loadScripts: (consent: AnalyticsConsent) => Promise<void>;
  unloadScripts: (consent: AnalyticsConsent) => Promise<void>;
  reloadScripts: () => Promise<void>;
  preloadScripts: (consent: AnalyticsConsent) => Promise<void>;
  clearCache: () => void;
  retryFailedScripts: () => Promise<void>;
  getScriptStatus: (scriptId: string) => LoadedScript | null;
}

export function useScriptManager(
  options: ScriptManagerOptions = {}
): ScriptManagerState & ScriptManagerActions {
  const {
    endpoint = '/analytics/scripts',
    enablePreloading = true,
    enableCaching = true,
    enableCrossTabSync = true,
    retryAttempts = 3,
    retryDelayMs = 1000,
    onScriptLoad,
    onScriptError,
    onConsentChange,
  } = options;

  // State
  const [scripts, setScripts] = useState<Map<string, LoadedScript>>(new Map());
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | undefined>();
  const [consent, setConsent] = useState<AnalyticsConsent>(getDefaultConsent());
  const [stats, setStats] = useState<ScriptManagerStats>(getEmptyStats());

  // Refs
  const scriptLoaderRef = useRef<ScriptLoader>();
  const scriptCacheRef = useRef<ScriptCache>();
  const retryTimeoutsRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const isInitializedRef = useRef(false);

  // Initialize script loader and cache
  useEffect(() => {
    if (!isInitializedRef.current) {
      scriptLoaderRef.current = new ScriptLoader({
        retryAttempts,
        retryDelayMs,
        onScriptLoad: handleScriptLoad,
        onScriptError: handleScriptError,
      });

      if (enableCaching) {
        scriptCacheRef.current = new ScriptCache();
      }

      isInitializedRef.current = true;
    }

    return () => {
      // Cleanup on unmount
      retryTimeoutsRef.current.forEach(timeout => clearTimeout(timeout));
      retryTimeoutsRef.current.clear();
    };
  }, []);

  // Handle script load success
  const handleScriptLoad = useCallback((script: LoadedScript) => {
    setScripts(prev => {
      const newScripts = new Map(prev);
      newScripts.set(script.id, script);
      return newScripts;
    });

    updateStats();
    onScriptLoad?.(script);
  }, [onScriptLoad]);

  // Handle script load error
  const handleScriptError = useCallback((error: ScriptError) => {
    setScripts(prev => {
      const newScripts = new Map(prev);
      const script = newScripts.get(error.scriptId);
      if (script) {
        newScripts.set(error.scriptId, {
          ...script,
          error: error.error.message,
        });
      }
      return newScripts;
    });

    updateStats();
    onScriptError?.(error);
  }, [onScriptError]);

  // Update statistics
  const updateStats = useCallback(() => {
    setStats(prev => {
      const scriptArray = Array.from(scripts.values());
      const loadedCount = scriptArray.filter(s => s.loaded).length;
      const failedCount = scriptArray.filter(s => s.error).length;
      const totalLoadTime = scriptArray.reduce((sum, s) => sum + s.loadTime, 0);
      
      return {
        totalScripts: scriptArray.length,
        loadedScripts: loadedCount,
        failedScripts: failedCount,
        averageLoadTime: scriptArray.length > 0 ? totalLoadTime / scriptArray.length : 0,
        lastUpdate: Date.now(),
      };
    });
  }, [scripts]);

  // Load scripts based on consent
  const loadScripts = useCallback(async (newConsent: AnalyticsConsent) => {
    if (!scriptLoaderRef.current) return;

    setLoading(true);
    setError(undefined);

    try {
      // Fetch script definitions from endpoint
      const scriptDefinitions = await fetchScriptDefinitions(newConsent);
      
      // Load each script
      const loadPromises = scriptDefinitions.map(async (scriptDef) => {
        try {
          // Check cache first
          if (enableCaching && scriptCacheRef.current) {
            const cachedScript = await scriptCacheRef.current.get(scriptDef.id);
            if (cachedScript) {
              handleScriptLoad(cachedScript);
              return;
            }
          }

          // Load script
          const script = await scriptLoaderRef.current!.loadScript(scriptDef);
          
          // Cache if enabled
          if (enableCaching && scriptCacheRef.current) {
            await scriptCacheRef.current.set(scriptDef.id, script);
          }

          handleScriptLoad(script);
        } catch (error) {
          handleScriptError({
            scriptId: scriptDef.id,
            error: error as Error,
            retryCount: 0,
            timestamp: Date.now(),
          });
        }
      });

      await Promise.allSettled(loadPromises);

      // Update consent state
      setConsent(newConsent);
      onConsentChange?.(newConsent);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to load scripts';
      setError(errorMessage);
    } finally {
      setLoading(false);
    }
  }, [enableCaching, onConsentChange, onScriptLoad, onScriptError]);

  // Unload scripts that are no longer needed
  const unloadScripts = useCallback(async (newConsent: AnalyticsConsent) => {
    if (!scriptLoaderRef.current) return;

    const scriptsToUnload = Array.from(scripts.values()).filter(script => {
      // Check if script is no longer needed based on new consent
      return !isScriptNeeded(script, newConsent);
    });

    for (const script of scriptsToUnload) {
      try {
        await scriptLoaderRef.current.unloadScript(script.id);
        
        setScripts(prev => {
          const newScripts = new Map(prev);
          newScripts.delete(script.id);
          return newScripts;
        });

        // Remove from cache
        if (enableCaching && scriptCacheRef.current) {
          await scriptCacheRef.current.remove(script.id);
        }
      } catch (error) {
        console.warn('Failed to unload script', { scriptId: script.id, error });
      }
    }

    updateStats();
  }, [scripts, enableCaching]);

  // Reload all scripts
  const reloadScripts = useCallback(async () => {
    await loadScripts(consent);
  }, [consent, loadScripts]);

  // Preload scripts for better performance
  const preloadScripts = useCallback(async (newConsent: AnalyticsConsent) => {
    if (!enablePreloading || !scriptLoaderRef.current) return;

    try {
      const scriptDefinitions = await fetchScriptDefinitions(newConsent);
      
      // Preload scripts without adding to state
      const preloadPromises = scriptDefinitions.map(scriptDef =>
        scriptLoaderRef.current!.preloadScript(scriptDef)
      );

      await Promise.allSettled(preloadPromises);
    } catch (error) {
      console.warn('Failed to preload scripts', error);
    }
  }, [enablePreloading]);

  // Clear script cache
  const clearCache = useCallback(() => {
    if (scriptCacheRef.current) {
      scriptCacheRef.current.clear();
    }
  }, []);

  // Retry failed scripts
  const retryFailedScripts = useCallback(async () => {
    const failedScripts = Array.from(scripts.values()).filter(s => s.error);
    
    for (const script of failedScripts) {
      try {
        await scriptLoaderRef.current!.retryScript(script.id);
      } catch (error) {
        console.warn('Failed to retry script', { scriptId: script.id, error });
      }
    }
  }, [scripts]);

  // Get script status
  const getScriptStatus = useCallback((scriptId: string): LoadedScript | null => {
    return scripts.get(scriptId) || null;
  }, [scripts]);

  // Fetch script definitions from endpoint
  const fetchScriptDefinitions = async (consent: AnalyticsConsent): Promise<ScriptDefinition[]> => {
    const consentParams = new URLSearchParams();
    Object.entries(consent).forEach(([key, value]) => {
      consentParams.append(key, value.toString());
    });

    const response = await fetch(`${endpoint}?${consentParams.toString()}`);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch scripts: ${response.status}`);
    }

    const data = await response.json();
    return data.scripts || [];
  };

  // Check if script is needed based on consent
  const isScriptNeeded = (script: LoadedScript, newConsent: AnalyticsConsent): boolean => {
    // Implementation would check if script's required consent is met
    return Object.entries(script.consent).every(([key, value]) => {
      return !value || newConsent[key as keyof AnalyticsConsent];
    });
  };

  // Cross-tab synchronization
  useEffect(() => {
    if (!enableCrossTabSync) return;

    const handleStorageChange = (event: StorageEvent) => {
      if (event.key === 'c15t-scripts' && event.newValue) {
        try {
          const newScripts = JSON.parse(event.newValue);
          setScripts(new Map(newScripts));
        } catch (error) {
          console.warn('Failed to parse scripts from storage', error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, [enableCrossTabSync]);

  // Sync scripts to storage for cross-tab communication
  useEffect(() => {
    if (!enableCrossTabSync) return;

    try {
      localStorage.setItem('c15t-scripts', JSON.stringify(Array.from(scripts.entries())));
    } catch (error) {
      console.warn('Failed to sync scripts to storage', error);
    }
  }, [scripts, enableCrossTabSync]);

  return {
    scripts,
    loading,
    error,
    consent,
    stats,
    loadScripts,
    unloadScripts,
    reloadScripts,
    preloadScripts,
    clearCache,
    retryFailedScripts,
    getScriptStatus,
  };
}

// Helper functions
function getDefaultConsent(): AnalyticsConsent {
  return {
    necessary: true,
    measurement: false,
    marketing: false,
    functionality: false,
    experience: false,
  };
}

function getEmptyStats(): ScriptManagerStats {
  return {
    totalScripts: 0,
    loadedScripts: 0,
    failedScripts: 0,
    averageLoadTime: 0,
    lastUpdate: Date.now(),
  };
}

// Script Definition Interface
interface ScriptDefinition {
  id: string;
  type: string;
  src: string;
  requiredConsent: string[];
  attributes?: Record<string, string>;
}
```

### Script Loader Utility
```typescript
export interface ScriptLoaderOptions {
  retryAttempts: number;
  retryDelayMs: number;
  onScriptLoad: (script: LoadedScript) => void;
  onScriptError: (error: ScriptError) => void;
}

export class ScriptLoader {
  private loadedScripts = new Map<string, HTMLScriptElement>();
  private loadingPromises = new Map<string, Promise<LoadedScript>>();

  constructor(private options: ScriptLoaderOptions) {}

  async loadScript(definition: ScriptDefinition): Promise<LoadedScript> {
    const { id, src, type, requiredConsent, attributes = {} } = definition;

    // Return existing promise if already loading
    if (this.loadingPromises.has(id)) {
      return this.loadingPromises.get(id)!;
    }

    const loadPromise = this.performLoad(id, src, type, requiredConsent, attributes);
    this.loadingPromises.set(id, loadPromise);

    try {
      const script = await loadPromise;
      this.loadingPromises.delete(id);
      return script;
    } catch (error) {
      this.loadingPromises.delete(id);
      throw error;
    }
  }

  private async performLoad(
    id: string,
    src: string,
    type: string,
    requiredConsent: string[],
    attributes: Record<string, string>
  ): Promise<LoadedScript> {
    const startTime = Date.now();

    return new Promise((resolve, reject) => {
      // Check if script already exists
      if (this.loadedScripts.has(id)) {
        const existingScript = this.loadedScripts.get(id)!;
        resolve({
          id,
          type,
          src,
          loaded: true,
          loadTime: Date.now() - startTime,
          consent: this.getConsentFromRequired(requiredConsent),
        });
        return;
      }

      // Create script element
      const script = document.createElement('script');
      script.src = src;
      script.type = 'text/javascript';
      script.async = true;

      // Set attributes
      Object.entries(attributes).forEach(([key, value]) => {
        script.setAttribute(key, value);
      });

      // Handle load success
      script.onload = () => {
        this.loadedScripts.set(id, script);
        
        const loadedScript: LoadedScript = {
          id,
          type,
          src,
          loaded: true,
          loadTime: Date.now() - startTime,
          consent: this.getConsentFromRequired(requiredConsent),
        };

        this.options.onScriptLoad(loadedScript);
        resolve(loadedScript);
      };

      // Handle load error
      script.onerror = (error) => {
        const scriptError: ScriptError = {
          scriptId: id,
          error: new Error(`Failed to load script: ${src}`),
          retryCount: 0,
          timestamp: Date.now(),
        };

        this.options.onScriptError(scriptError);
        reject(scriptError.error);
      };

      // Append to document
      document.head.appendChild(script);
    });
  }

  async unloadScript(id: string): Promise<void> {
    const script = this.loadedScripts.get(id);
    if (script) {
      script.remove();
      this.loadedScripts.delete(id);
    }
  }

  async preloadScript(definition: ScriptDefinition): Promise<void> {
    const { src, attributes = {} } = definition;

    // Create preload link
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'script';
    link.href = src;

    // Set attributes
    Object.entries(attributes).forEach(([key, value]) => {
      link.setAttribute(key, value);
    });

    document.head.appendChild(link);
  }

  async retryScript(id: string): Promise<LoadedScript> {
    // Implementation would retry loading the script
    throw new Error('Retry not implemented');
  }

  private getConsentFromRequired(requiredConsent: string[]): AnalyticsConsent {
    const consent: AnalyticsConsent = {
      necessary: true,
      measurement: false,
      marketing: false,
      functionality: false,
      experience: false,
    };

    requiredConsent.forEach(purpose => {
      if (purpose in consent) {
        consent[purpose as keyof AnalyticsConsent] = true;
      }
    });

    return consent;
  }
}
```

### Script Cache Utility
```typescript
export class ScriptCache {
  private cache = new Map<string, LoadedScript>();
  private config = {
    maxSize: 100,
    ttlMs: 60 * 60 * 1000, // 1 hour
  };

  async get(id: string): Promise<LoadedScript | null> {
    const cached = this.cache.get(id);
    if (!cached) return null;

    // Check if expired
    if (Date.now() - cached.loadTime > this.config.ttlMs) {
      this.cache.delete(id);
      return null;
    }

    return cached;
  }

  async set(id: string, script: LoadedScript): Promise<void> {
    // Remove oldest if cache is full
    if (this.cache.size >= this.config.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }

    this.cache.set(id, script);
  }

  async remove(id: string): Promise<void> {
    this.cache.delete(id);
  }

  clear(): void {
    this.cache.clear();
  }

  size(): number {
    return this.cache.size;
  }
}
```

## 🧪 Testing Requirements
- Unit tests for script loading/unloading
- Unit tests for consent-aware script management
- Unit tests for script deduplication
- Unit tests for error handling
- Unit tests for cross-tab synchronization
- Integration tests with consent system
- Performance tests for script loading

## 🔍 Definition of Done
- [ ] useScriptManager hook implemented
- [ ] Dynamic script loading/unloading working
- [ ] Consent-aware script management implemented
- [ ] Script deduplication implemented
- [ ] Error handling for script failures implemented
- [ ] Cross-tab synchronization implemented
- [ ] Unit tests for script management
- [ ] Integration tests with consent system
- [ ] Code review completed

## 📚 Related Documentation
- [Analytics Frontend Integration](../docs/analytics-frontend-integration.md)
- [Analytics Architecture Diagram](../docs/analytics-architecture-diagram.md)

## 🔗 Dependencies
- [5.4: Error Handling & Retry Logic](./25-error-handling-retry.md) ✅

## 🚀 Next Ticket
[5.6: Implement Consent State Synchronization](./27-consent-state-sync.md)
