
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id               String       @id
  isIdentified     Boolean
  externalId       String?      @db.Text
  identityProvider String?      @db.Text
  lastIpAddress    String?      @db.Text
  createdAt        DateTime
  updatedAt        DateTime
  consents         Consent[]
  records          Record[]
  withdrawals      Withdrawal[]
  auditlogs        AuditLog[]
}

model Purpose {
  id               String            @id
  code             String            @db.Text
  name             String            @db.Text
  description      String            @db.Text
  isEssential      Boolean
  dataCategory     String?           @db.Text
  legalBasis       String?           @db.Text
  isActive         Boolean
  createdAt        DateTime
  updatedAt        DateTime
  purposejunctions PurposeJunction[]
}

model ConsentPolicy {
  id             String    @id
  version        String    @db.Text
  name           String    @db.Text
  effectiveDate  DateTime
  expirationDate DateTime?
  content        String    @db.Text
  contentHash    String    @db.Text
  isActive       Boolean
  createdAt      DateTime
  consents       Consent[]
}

model Domain {
  id             String    @id
  name           String
  description    String?   @db.Text
  allowedOrigins String[]
  isVerified     Boolean
  isActive       Boolean
  createdAt      DateTime
  updatedAt      DateTime?
  consents       Consent[]

  @@unique([name])
}

model Consent {
  id                  String               @id
  userId              String
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  domainId            String
  domain              Domain               @relation(fields: [domainId], references: [id], onDelete: Cascade)
  purposeIds          String[]
  policyId            String?
  consentpolicy       ConsentPolicy        @relation(fields: [policyId], references: [id], onDelete: Cascade)
  status              String               @db.Text
  withdrawalReason    String?              @db.Text
  ipAddress           String?              @db.Text
  userAgent           String?              @db.Text
  metadata            String[]
  createdAt           DateTime
  updatedAt           DateTime?
  expiresAt           DateTime?
  purposejunctions    PurposeJunction[]
  records             Record[]
  consentgeolocations ConsentGeoLocation[]
  withdrawals         Withdrawal[]
}

model PurposeJunction {
  id        String    @id
  consentId String
  consent   Consent   @relation(fields: [consentId], references: [id], onDelete: Cascade)
  purposeId String
  purpose   Purpose   @relation(fields: [purposeId], references: [id], onDelete: Cascade)
  status    String    @db.Text
  metadata  String[]
  createdAt DateTime
  updatedAt DateTime?
}

model Record {
  id         String   @id
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  consentId  String?
  consent    Consent  @relation(fields: [consentId], references: [id], onDelete: Cascade)
  actionType String   @db.Text
  details    String[]
  createdAt  DateTime
}

model ConsentGeoLocation {
  id        String   @id
  consentId String
  consent   Consent  @relation(fields: [consentId], references: [id], onDelete: Cascade)
  ip        String   @db.Text
  country   String?  @db.Text
  region    String?  @db.Text
  city      String?  @db.Text
  latitude  Int?
  longitude Int?
  timezone  String?  @db.Text
  createdAt DateTime
}

model Withdrawal {
  id               String   @id
  consentId        String
  consent          Consent  @relation(fields: [consentId], references: [id], onDelete: Cascade)
  userId           String
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  withdrawalReason String?  @db.Text
  withdrawalMethod String   @db.Text
  ipAddress        String?  @db.Text
  userAgent        String?  @db.Text
  metadata         String[]
  createdAt        DateTime
}

model AuditLog {
  id         String   @id
  entityType String   @db.Text
  entityId   String   @db.Text
  actionType String   @db.Text
  userId     String?
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress  String?  @db.Text
  userAgent  String?  @db.Text
  changes    String[]
  metadata   String[]
  createdAt  DateTime
}

model GeoLocation {
  id              String   @id
  countryCode     String   @db.Text
  countryName     String   @db.Text
  regionCode      String?  @db.Text
  regionName      String?  @db.Text
  regulatoryZones String[]
  createdAt       DateTime
}
